import { useState, useEffect } from 'react';
import Head from 'next/head';
import TopNavigation from '../components/TopNavigation';
import { extractFullText, generateAccurateAnalysis } from '../lib/fullTextExtractor';
import { callLLM } from '../lib/ai';
import { 
  ALL_ACADEMIC_DATABASES, 
  getDatabasesByCategory,
  getDatabaseStats,
  type AcademicDatabase
} from '../lib/academicDatabases';

// 定義類型接口
interface Reference {
  id: string;
  title: string;
  authors: string;
  source: string;
  year: number;
  summary: string;
  keySentences: string[];
  citation: string;
  database?: string; // 新增：標注數據庫來源
  url?: string; // 新增：文獻鏈接
  doi?: string; // 新增：DOI
  fileUrl?: string; // 新增：PDF文件URL
  fileName?: string; // 新增：PDF文件名
  fileSize?: number; // 新增：PDF文件大小
  deepAnalysis?: { // 新增：深度分析結果
    chineseExplanation: string;
    englishSentences: Array<{english: string, chinese: string}>;
    source: 'pdf' | 'html' | 'api' | 'unavailable' | 'PAGE_EXTRACT';
    analyzedAt: string;
    metadata?: { // 新增：元数据信息
      verified: boolean;
      has_abstract: boolean;
      abstract_length: number;
      body_length: number;
      summary_mode: 'AI_from_abstract' | 'AI_from_metadata_only';
      abstract_source?: string;
    };
  };
}

interface OutlinePoint {
  id: number;
  title: string;
  content: string;
  bulletPoints: string[];
  references: Reference[];
  wordCount: number;
}

export default function HomePage() {
  const [form, setForm] = useState({
    title: "",
    introWords: 140, // 新增狀態來控制引言字數
    bodyCount: 3, // 新增狀態來控制主體段落數量
    bodyWords: [240, 240, 240], // 新增狀態來控制每段主體的字數
    bodyContent: ['', '', ''], // 新增狀態來控制每段主體的內容描述
    conclusionWords: 140, // 新增狀態來控制結論字數
    totalWords: 1000, // 新增狀態來控制總字數
    rubric: "",
    language: "中文",
    tone: "正式",
    detail: "",
    plannerExpanded: false, // 新增狀態來控制段落規劃器是否展開
    settingsExpanded: true, // 新增狀態來控制功課設定是否展開
    referenceSettingsExpanded: false, // 新增狀態來控制参考文献设置是否展開
    
    // 参考文献设置
    referenceSettings: {
      documentTypes: ["journal", "book", "conference"],
      citationFormat: "apa7",
      region: "global",
      language: "en",
      yearRange: {
        from: 2010,
        to: new Date().getFullYear(),
      },
      sources: ["googlescholar", "semanticscholar", "crossref"],
      excludeLoginRequiredPublishers: true, // 新增：自动排除需登录的出版商
    },
  });

  const [activeTab, setActiveTab] = useState<'outline' | 'draft' | 'review' | 'revision' | 'final'>('outline');
  const [mode, setMode] = useState('edit');
  const [lockedTabs, setLockedTabs] = useState({
    outline: false,
    draft: false,
    review: false,
    revision: false,
    final: false
  });

  const [isGenerating, setIsGenerating] = useState(false);
  const [generatedContent, setGeneratedContent] = useState('');
  const [draftSections, setDraftSections] = useState<{[key: number]: string}>({});
  const [currentGeneratingSection, setCurrentGeneratingSection] = useState<number | null>(null);
  const [selectedModel, setSelectedModel] = useState('gpt-4o');
  
  // 新增：大綱點結構
  const [outlinePoints, setOutlinePoints] = useState<OutlinePoint[]>([]);

  // 新增：搜尋關鍵字（每個大綱點獨立）
  const [searchKeywords, setSearchKeywords] = useState<{[key: string]: string}>({});
  const [selectedBulletPoint, setSelectedBulletPoint] = useState<string | null>(null);
  const [isSearching, setIsSearching] = useState(false);
  const [analyzingReferences, setAnalyzingReferences] = useState<Set<string>>(new Set());
  const [searchResults, setSearchResults] = useState<Reference[]>([]);
  const [selectedReferences, setSelectedReferences] = useState<Reference[]>([]);

  const toggleLock = (tabName: 'outline' | 'draft' | 'review' | 'revision' | 'final') => {
    setLockedTabs(prev => ({
      ...prev,
      [tabName]: !prev[tabName]
    }));
  };

  const isCurrentTabLocked = lockedTabs[activeTab];

  // 保存参考文献设置到本地存储
  const saveReferenceSettings = (settings: any) => {
    try {
      localStorage.setItem('referenceSettings', JSON.stringify(settings));
      console.log('参考文献设置已保存:', settings);
    } catch (error) {
      console.error('保存设置失败:', error);
    }
  };

  // 从本地存储加载参考文献设置
  const loadReferenceSettings = () => {
    try {
      const saved = localStorage.getItem('referenceSettings');
      if (saved) {
        const settings = JSON.parse(saved);
        console.log('加载保存的设置:', settings);
        return settings;
      }
    } catch (error) {
      console.error('加载设置失败:', error);
    }
    return null;
  };

  // 组件加载时恢复设置
  useEffect(() => {
    const savedSettings = loadReferenceSettings();
    if (savedSettings) {
      setForm(prev => ({
        ...prev,
        referenceSettings: savedSettings
      }));
    }
  }, []);

  // 更新参考文献设置
  const updateReferenceSettings = (newSettings: any) => {
    setForm(prev => ({
      ...prev,
      referenceSettings: { ...prev.referenceSettings, ...newSettings }
    }));
    saveReferenceSettings({ ...form.referenceSettings, ...newSettings });
  };

  // 生成用戶個性化上下文
  const generateUserContext = () => {
    const timestamp = Date.now();
    const sessionId = Math.random().toString(36).substring(2, 15);
    const userAgent = navigator.userAgent;
    const timeOfDay = new Date().getHours();
    const dayOfWeek = new Date().getDay();
    
    return {
      timestamp,
      sessionId,
      userAgent: userAgent.substring(0, 50), // 限制长度
      timeOfDay,
      dayOfWeek,
      randomSeed: Math.random().toString(36).substring(2, 10)
    };
  };

  // 生成個性化大綱
  const generatePersonalizedOutline = (keywords: string, enhancedKeyword: string, userContext: any, pointId: number) => {
    const timeVariations = ['早期', '中期', '近期', '当代', '现代', '最新', '前沿', '新兴'];
    const approachVariations = ['理论', '实践', '实证', '比较', '案例', '实验', '仿真', '模拟'];
    const perspectiveVariations = ['技术', '应用', '发展', '挑战', '机遇', '影响', '价值', '趋势'];
    
    const timeVar = timeVariations[userContext.timeOfDay % timeVariations.length];
    const approachVar = approachVariations[userContext.dayOfWeek % approachVariations.length];
    const perspectiveVar = perspectiveVariations[pointId % perspectiveVariations.length];
    
    return `一、${timeVar}${keywords}的${approachVar}研究
${enhancedKeyword}在${perspectiveVar}层面的重要发现和创新

二、${keywords}的${approachVar}应用
${enhancedKeyword}在实际场景中的表现和效果分析

三、${keywords}的未来${perspectiveVar}
${enhancedKeyword}的发展方向和潜在突破`;
  };

  // 新增：草稿生成功能
  const handleGenerateDraft = async (type: 'full' | 'section', sectionId?: number) => {
    if (!form.title.trim()) {
      alert('請先輸入論文標題');
      return;
    }

    if (outlinePoints.length === 0) {
      alert('請先創建大綱結構');
      return;
    }

    // 检查参考文献
    const allReferences = outlinePoints.flatMap(point => point.references);
    if (allReferences.length === 0) {
      const confirmGenerate = confirm('⚠️ 警告：您还没有添加任何参考文献。\n\n建议先添加参考文献以获得更好的生成效果。\n\n是否仍要继续生成？');
      if (!confirmGenerate) {
        return;
      }
    }

    // 检查字数设置
    if (form.totalWords < 500) {
      const confirmWordCount = confirm(`⚠️ 字数设置较低（${form.totalWords}字）。\n\n建议至少设置500字以获得更好的内容质量。\n\n是否仍要继续？`);
      if (!confirmWordCount) {
        return;
      }
    }

    setIsGenerating(true);
    if (sectionId) {
      setCurrentGeneratingSection(sectionId);
    }

    try {
      // 构建大纲文本
      const outlineText = outlinePoints.map(point => 
        `${point.id}. ${point.title}\n${point.content}\n${point.bulletPoints && point.bulletPoints.length > 0 ? point.bulletPoints.map(detail => `• ${detail}`).join('\n') : ''}`
      ).join('\n\n');

      // 收集所有参考文献
      const referenceText = allReferences.length > 0 
        ? allReferences.map((ref, index) => {
            const year = ref.year || new Date().getFullYear();
            return `${index + 1}. ${ref.authors} (${year}). ${ref.title}. ${ref.source}`;
          }).join('\n')
        : '';

      let prompt = '';
      let wordCount = form.totalWords || 1000;
      
      // 确保字数设置正确
      console.log('设置的字数:', wordCount);
      console.log('form.totalWords:', form.totalWords);

      if (type === 'full') {
        // 生成完整草稿
        prompt = `請根據以下大綱和參考文獻撰寫一篇約${wordCount}字的完整文章：
題目：${form.title}
語言：${form.language}
語氣：${form.tone}

大綱：
${outlineText}

參考文獻：
${referenceText}

請撰寫一篇完整的文章，包含引言、主體段落和結論。`;
      } else if (type === 'section' && sectionId !== undefined) {
        // 生成單個段落
        const section = outlinePoints.find(point => point.id === sectionId);
        if (!section) {
          alert('找不到指定的段落');
          return;
        }

        const sectionReferences = section.references.length > 0 
          ? section.references.map((ref, index) => {
              const year = ref.year || new Date().getFullYear();
              return `${index + 1}. ${ref.authors} (${year}). ${ref.title}. ${ref.source}`;
            }).join('\n')
          : '';
        
        prompt = `請根據以下段落大綱和參考文獻撰寫約${section.wordCount || 240}字的段落：
段落標題：${section.title}
段落內容：${section.content}
要點：${section.bulletPoints.join('\n')}

參考文獻：
${sectionReferences}

請撰寫這個段落的完整內容。`;
      }

      // 調用 AI 生成內容
      const response = await callLLM([{ role: 'user', content: prompt }], { model: selectedModel });
      
      if (type === 'full') {
        setGeneratedContent(response);
        setActiveTab('draft');
        alert('✅ 完整草稿生成成功！所有段落内容已自动填充到相应区域。');
      } else if (type === 'section' && sectionId !== undefined) {
        setDraftSections(prev => ({
          ...prev,
          [sectionId]: response
        }));
        alert(`✅ 第${sectionId}段生成成功！`);
      }

    } catch (error) {
      console.error('生成草稿失敗:', error);
      alert('生成失敗，請檢查網絡連接');
    } finally {
      setIsGenerating(false);
      setCurrentGeneratingSection(null);
    }
  };

  // 新增：搜尋文獻
  const handleSearchReferences = async (keyword: string, pointId: number, useAIEnhancement: boolean = false) => {
    if (!keyword.trim()) return;
    
    setIsSearching(true);
    
    try {
      let finalKeyword = keyword;
      
      // 获取文献库中的PDF信息
      const getLibraryPdfInfo = async (title: string) => {
        try {
          const response = await fetch('/api/reference-library');
          if (response.ok) {
            const library = await response.json();
            const libraryEntry = library.find((entry: any) => 
              entry.title.toLowerCase().includes(title.toLowerCase()) ||
              title.toLowerCase().includes(entry.title.toLowerCase())
            );
            return libraryEntry ? {
              fileUrl: libraryEntry.fileUrl,
              fileName: libraryEntry.fileName,
              fileSize: libraryEntry.fileSize,
              verified: libraryEntry.verified
            } : null;
          }
        } catch (error) {
          console.log('获取文献库信息失败:', error);
        }
        return null;
      };
      
      // 自动访问网站并提取内容进行分析
      const enhancedSearch = async (references: Reference[]) => {
        console.log('开始自动访问网站并提取内容...');
        
        const enhancedRefs = await Promise.all(
          references.map(async (ref) => {
            if (ref.url) {
              try {
                console.log(`访问网站: ${ref.url}`);
                const fullTextResult = await extractFullText(ref.url);
                
                if (fullTextResult.success && fullTextResult.content) {
                  console.log(`成功提取内容，长度: ${fullTextResult.content.length}`);
                  
                  // 基于网站内容生成准确分析
                  const analysis = await generateAccurateAnalysis(ref.title, fullTextResult.content, pointId);
                  
                  return {
                    ...ref,
                    deepAnalysis: {
                      chineseExplanation: analysis.chineseExplanation,
                      englishSentences: analysis.englishSentences,
                      source: fullTextResult.source,
                      analyzedAt: new Date().toISOString()
                    }
                  };
                }
              } catch (error) {
                console.log(`访问网站失败: ${ref.url}`, error);
              }
            }
            return ref;
          })
        );
        
        return enhancedRefs;
      };
      
      let personalizedOutline: string;
      let userContext: any;
      
      if (useAIEnhancement) {
    // 生成完全個性化的關鍵字，包含用戶上下文和時間戳
        userContext = generateUserContext();
    const aiGeneratedKeywords = generateAIKeywords(keyword, pointId, userContext);
    console.log('AI生成的個性化關鍵字:', aiGeneratedKeywords);
        setSearchKeywords(prev => ({...prev, [pointId]: aiGeneratedKeywords}));
    
      // 優化搜尋關鍵字，增加相關詞彙提高搜尋準確性
      const enhancedKeyword = enhanceSearchKeyword(aiGeneratedKeywords, pointId);
        finalKeyword = enhancedKeyword;
        
        // 添加用戶個性化信息到搜索请求中
        personalizedOutline = generatePersonalizedOutline(aiGeneratedKeywords, enhancedKeyword, userContext, pointId);
      } else {
        // 使用用戶手動輸入的關鍵字，不進行AI增強
        console.log('使用用戶手動輸入的關鍵字:', keyword);
        userContext = generateUserContext(); // 仍然需要userContext用于API调用
        personalizedOutline = keyword;
      }
      
      // 使用更簡單的搜尋方式，直接調用現有的API
      const response = await fetch('/api/references/suggest', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          outline: personalizedOutline,
          userContext: userContext,
          pointId: pointId,
          settings: form.referenceSettings
        }),
      });

      if (!response.ok) {
        throw new Error(`搜尋失敗: ${response.status}`);
      }

      const data = await response.json();
      
      // 轉換API返回的格式為前端需要的格式
      const convertedResults: Reference[] = [];
      const seenTitles = new Set<string>();
      
      data.forEach((section: any) => {
        section.references.forEach((ref: any, index: number) => {
          // 跳過沒有標題的結果
          if (!ref.title || 
              ref.title === '引言' || 
              ref.title.includes('建議研究方向') ||
              ref.title.toLowerCase().includes('introduction') ||
              ref.title.toLowerCase().includes('引言')) return;
          
          // 去重：跳過已經處理過的標題
          const titleKey = ref.title.toLowerCase().trim();
          if (seenTitles.has(titleKey)) return;
          seenTitles.add(titleKey);
          
          // 使用真實的摘要，而不是模板
          const realSummary = ref.abstract || ref.summary || 'No abstract available';
          
          convertedResults.push({
            id: `ref-${Date.now()}-${index}`,
            title: ref.title || '未知標題',
            authors: Array.isArray(ref.authors) ? ref.authors.join(', ') : (ref.authors || '未知作者'),
            source: ref.source || '未知來源',
            year: ref.year || 2024,
            summary: realSummary,
            keySentences: [], // 移除模板化的關鍵句子
            citation: `${Array.isArray(ref.authors) ? ref.authors.join(', ') : (ref.authors || '未知作者')}. (${ref.year || 2024}). ${ref.title}. ${ref.source}.`,
            database: ref.database || '未知數據庫',
            url: ref.url || null
          });
        });
      });

      // 增加搜索数量，确保能找到足够多的已验证文献
      const targetVerifiedCount = 3;
      let searchBatchSize = Math.min(convertedResults.length, 10); // 每次处理最多10篇
      let batchVerifiedCount = 0;
      let enhancedResults: any[] = [];
      
      console.log(`开始使用专业元数据抓取系统，目标找到${targetVerifiedCount}篇已验证文献...`);
      
      // 分批处理，直到找到足够的已验证文献
      while (batchVerifiedCount < targetVerifiedCount && enhancedResults.length < convertedResults.length) {
        const batchStart = enhancedResults.length;
        const batchEnd = Math.min(batchStart + searchBatchSize, convertedResults.length);
        const currentBatch = convertedResults.slice(batchStart, batchEnd);
        
        console.log(`处理第${Math.floor(batchStart/searchBatchSize) + 1}批文献 (${batchStart + 1}-${batchEnd})，当前已验证: ${batchVerifiedCount}篇`);
        
        const batchResults = await Promise.all(
          currentBatch.map(async (ref) => {
          try {
            console.log(`抓取文献元数据: ${ref.title}`);
            
            // 提取DOI（如果有的话）
            const doiMatch = ref.url?.match(/doi\.org\/([^\/\s]+)/);
            const doi = doiMatch ? doiMatch[1] : null;
            
            // Step 1: 优先尝试从页面URL直接抓取摘要
            if (ref.url) {
              console.log(`[Step 1] 尝试从页面抓取: ${ref.url}`);
              try {
                const pageResponse = await fetch('/api/abstract', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ url: ref.url, title: ref.title }),
                });
                
                if (pageResponse.ok) {
                  const pageData = await pageResponse.json();
                  console.log(`[Step 1] 页面抓取结果:`, {
                    verified: pageData.verified,
                    hasChineseSummary: !!pageData.chineseSummary
                  });
                  
                  if (pageData.success && pageData.chineseSummary) {
                    console.log(`✅ [Step 1] 成功 - 中文概述: ${pageData.chineseSummary.substring(0, 100)}...`);
                    return {
                      ...ref,
                      deepAnalysis: {
                        chineseExplanation: pageData.chineseSummary,
                        englishSentences: [],
                        source: pageData.source || 'PAGE_EXTRACT',
                        analyzedAt: new Date().toISOString(),
                        metadata: {
                          abstract: pageData.abstract,
                          summary_mode: pageData.summary_mode,
                          abstract_source: pageData.source || 'PAGE_EXTRACT',
                          verified: pageData.verified,
                          has_abstract: pageData.has_abstract,
                          has_body: pageData.has_body,
                          abstract_length: pageData.abstract_length,
                          body_length: pageData.body_length
                        }
                      }
                    };
                  }
                }
                console.log(`[Step 1] 失败 - 继续到Step 2`);
              } catch (error) {
                console.log(`[Step 1] 异常 - 继续到Step 2:`, error);
              }
            }
            
            // Step 2: 使用元数据API
            console.log(`[Step 2] 使用元数据API`);
            try {
              const metaResponse = await fetch('/api/english-paper', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ title: ref.title, doi: doi }),
              });
              
              if (metaResponse.ok) {
                const metaData = await metaResponse.json();
                console.log(`[Step 2] 元数据API结果:`, {
                  hasMetadata: !!metaData.metadata,
                  hasChineseSummary: !!metaData.chineseSummary
                });
                
                if (metaData.success && metaData.chineseSummary) {
                  console.log(`✅ [Step 2] 成功 - 中文概述: ${metaData.chineseSummary.substring(0, 100)}...`);
                  return {
                    ...ref,
                    deepAnalysis: {
                      chineseExplanation: metaData.chineseSummary,
                      englishSentences: [],
                      source: metaData.metadata?.abstract_source || 'metadata',
                      analyzedAt: new Date().toISOString(),
                      metadata: {
                        ...metaData.metadata,
                        verified: metaData.metadata?.verified || metaData.metadata?.has_abstract || false
                      }
                    }
                  };
                }
              }
              console.log(`[Step 2] 失败 - 继续到Step 3`);
            } catch (error) {
              console.log(`[Step 2] 异常 - 继续到Step 3:`, error);
            }
            
            // Step 3: 备用方案 - 自动翻译原始摘要
            console.log(`[Step 3] 使用备用方案`);
            
            // 如果有原始摘要（英文），自动翻译成中文
            if (ref.summary && ref.summary.length > 50) {
              try {
                const translationPrompt = `请将以下英文摘要翻译成2-3句中文概述，语气正式、学术：

${ref.summary}

请直接输出翻译结果，不要添加任何解释或格式。`;
                
                  const translationResponse = await callLLM([{ role: 'user', content: translationPrompt }], { model: selectedModel });
                
                if (translationResponse && translationResponse.trim()) {
                  console.log(`✅ [Step 3] 成功 - 翻译概述: ${translationResponse.substring(0, 100)}...`);
                  return {
                    ...ref,
                    deepAnalysis: {
                      chineseExplanation: translationResponse.trim(),
                      englishSentences: [],
                      source: 'api',
                      analyzedAt: new Date().toISOString(),
                      metadata: {
                        verified: false,
                        has_abstract: true,
                        abstract_length: ref.summary.length,
                        body_length: 0,
                        summary_mode: 'AI_from_metadata_only',
                        abstract_source: 'translation'
                      }
                    }
                  };
                }
              } catch (error) {
                console.log(`[Step 3] 翻译失败:`, error);
              }
            }
            
            // 如果所有步骤都失败，返回原始引用
            console.log(`❌ 所有步骤都失败，返回原始引用: ${ref.title}`);
            return ref;
              
          } catch (error) {
              console.log(`处理文献时出错: ${ref.title}`, error);
            return ref;
          }
          })
        );
        
        enhancedResults.push(...batchResults);
        batchVerifiedCount = batchResults.filter(ref => ref.deepAnalysis?.metadata?.verified).length;
        
        console.log(`第${Math.floor(batchStart/searchBatchSize) + 1}批处理完成，当前已验证: ${batchVerifiedCount}篇，总计: ${enhancedResults.length}篇`);
        
        // 如果已经找到足够的已验证文献，可以提前结束
        if (batchVerifiedCount >= targetVerifiedCount) {
          console.log(`✅ 已找到${batchVerifiedCount}篇已验证文献，满足要求`);
          break;
        }
      }
      
      // 更新搜索结果
      setSearchResults(enhancedResults);
      
      // 显示搜索结果统计
      const verifiedCount = enhancedResults.filter(ref => ref.deepAnalysis?.metadata?.verified).length;
      const hasChineseSummaryCount = enhancedResults.filter(ref => ref.deepAnalysis?.chineseExplanation).length;
      
      console.log(`搜索完成统计:`);
      console.log(`- 总文献数: ${enhancedResults.length}`);
      console.log(`- 已验证文献: ${verifiedCount}篇`);
      console.log(`- 有中文概述: ${hasChineseSummaryCount}篇`);
      
      // 给用户友好的反馈
      const verifiedResults = enhancedResults.filter(ref => ref.deepAnalysis?.metadata?.verified);
      console.log(`為大綱點 ${pointId} 搜尋文獻成功，搜索了 ${enhancedResults.length} 篇文獻，找到 ${verifiedResults.length} 篇已验证文献（目标: ${targetVerifiedCount}篇）`);
      
      if (verifiedResults.length >= targetVerifiedCount) {
        alert(`✅ 搜索完成！成功找到 ${verifiedResults.length} 篇已验证的高质量文献。\n\n所有显示的文献都包含真实摘要和准确的中文概述。`);
      } else if (verifiedResults.length > 0) {
        alert(`⚠️ 搜索完成，但只找到 ${verifiedResults.length} 篇已验证文献（目标: ${targetVerifiedCount}篇）。\n\n建议：\n• 尝试其他关键词\n• 启用"自动排除需登录出版商"选项\n• 选择更多开放获取数据库`);
      } else {
        alert(`❌ 搜索完成，但没有找到已验证的文献。\n\n建议：\n• 检查网络连接\n• 尝试不同的关键词\n• 启用"自动排除需登录出版商"选项\n• 选择更多开放获取数据库`);
      }
      
    } catch (error) {
      console.error('文獻搜尋失敗:', error);
      alert(`文獻搜尋失敗: ${error instanceof Error ? error.message : '未知錯誤'}`);
    } finally {
      setIsSearching(false);
    }
  };

  // 優化搜尋關鍵字，增加相關詞彙提高搜尋準確性
  const enhanceSearchKeyword = (keyword: string, pointId: number): string => {
    const enhancements: { [key: number]: string[] } = {
      1: ['人工智能', 'AI', 'artificial intelligence', '技術發展', '發展趨勢'],
      2: ['機器學習', '深度學習', '神經網絡', '算法', '技術原理'],
      3: ['AI應用', '實際應用', '案例分析', '應用前景'],
      4: ['AI挑戰', '發展挑戰', '未來展望', '技術挑戰'],
      5: ['AI價值', '社會影響', '技術價值', '發展意義']
    };
    
    const enhancement = enhancements[pointId] || ['人工智能', 'AI'];
    return `${keyword} ${enhancement.join(' ')}`;
  };

  // 為bullet point生成特定關鍵詞
  const generateBulletPointKeywords = (bullet: string, pointId: number, bulletIndex: number): string => {
    console.log(`為bullet point生成關鍵詞 - 要點: "${bullet}", 點ID: ${pointId}, 索引: ${bulletIndex}`);
    
    // 根據bullet點內容提取關鍵詞
    const bulletLower = bullet.toLowerCase();
    
    // 檢測關鍵學術領域關鍵詞
    const academicKeywords = [
      'AI', 'artificial intelligence', 'machine learning', 'deep learning', 'technology', 
      'algorithm', 'neural network', 'data science', 'automation', 'automation',
      'evolution', 'development', 'application', 'implementation', 'analysis',
      'trust', 'security', 'privacy', 'ethics', 'adoption', 'impact',
      'collaboration', 'integration', 'optimization', 'efficiency'
    ];
    
    // 根據要點內容生成針對性關鍵詞
    let generatedKeywords: string[] = [];
    
    if (bulletLower.includes('概念') || bulletLower.includes('concept') || bulletLower.includes('定義') || bulletLower.includes('definition')) {
      generatedKeywords = ['"artificial intelligence" "concept " "definition"'];
    } else if (bulletLower.includes('發展歷程') || bulletLower.includes('evolution') || bulletLower.includes('development') || bulletLower.includes('history')) {
      generatedKeywords = ['"AI evolution" "development history" "technological progress"'];
    } else if (bulletLower.includes('重要性') || bulletLower.includes('importance') || bulletLower.includes('significance') || bulletLower.includes('impact')) {
      generatedKeywords = ['"AI importance" "social impact" "technological significance"'];
    } else if (bulletLower.includes('應用') || bulletLower.includes('application') || bulletLower.includes('implementation')) {
      generatedKeywords = ['"AI applications" "practical implementation" "use cases"'];
    } else if (bulletLower.includes('挑戰') || bulletLower.includes('challenges') || bulletLower.includes('limitations')) {
      generatedKeywords = ['"AI challenges" "limitations" "obstacles"'];
    } else if (bulletLower.includes('未來') || bulletLower.includes('future') || bulletLower.includes('trend')) {
      generatedKeywords = ['"AI future" "emerging trends" "prospects"'];
    } else {
      // 檢測要點中的關鍵詞並組合
      const detectedKeywords = academicKeywords.filter(keyword => 
        bulletLower.includes(keyword.toLowerCase())
      );
      
      if (detectedKeywords.length >= 2) {
        // 如果有足夠的關鍵詞，使用前3個組合
        const selectedKeywords = detectedKeywords.slice(0, 3);
        generatedKeywords = [`"${selectedKeywords.join('" "')}"`];
      } else {
        // 使用通用關鍵詞
        generatedKeywords = ['"artificial intelligence" "technology" "research"'];
      }
    }
    
    // 隨機選擇一個關鍵詞組合
    const randomIndex = Math.floor(Math.random() * generatedKeywords.length);
    const finalKeywords = generatedKeywords[randomIndex];
    
    console.log(`最終為bullet point生成關鍵詞: "${finalKeywords}"`);
    return finalKeywords;
  };

  // 生成英文關鍵字（固定3個關鍵詞版本）
  const generateEnglishKeywords = (title: string, pointId: number): string => {
    console.log(`生成英文關鍵字 - 標題: "${title}", 點ID: ${pointId}`);
    
    // 根據大綱點標題和ID生成固定的3個關鍵詞
    const baseKeywords: { [key: number]: string[] } = {
      1: [
        '"artificial intelligence" "AI development" "technology"',
        '"AI" "technology evolution" "development"',
        '"machine intelligence" "AI progress" "technology"'
      ],
      2: [
        '"machine learning" "algorithms" "optimization"',
        '"deep learning" "neural networks" "AI"',
        '"AI algorithms" "machine learning" "optimization"'
      ],
      3: [
        '"AI applications" "real-world" "implementation"',
        '"intelligent systems" "AI solutions" "deployment"',
        '"AI applications" "real-world" "technology"'
      ],
      4: [
        '"AI challenges" "limitations" "ethics"',
        '"AI ethics" "ethical concerns" "challenges"',
        '"AI risks" "limitations" "mitigation"'
      ],
      5: [
        '"AI impact" "society" "benefits"',
        '"social implications" "artificial intelligence" "impact"',
        '"AI benefits" "human welfare" "society"'
      ]
    };
    
    const keywords = baseKeywords[pointId] || ['"artificial intelligence" "AI development" "technology"'];
    // 隨機選擇一個3個關鍵詞的組合
    const shuffled = keywords.sort(() => 0.5 - Math.random());
    const selected = shuffled[0];
    
    console.log(`選擇的3個關鍵詞組合: "${selected}"`);
    return selected;
  };

  // AI自動生成關鍵字（固定3個關鍵詞版本）
  const generateAIKeywords = (title: string, pointId: number, userContext: any): string => {
    console.log(`開始生成個性化英文關鍵字 - 標題: "${title}", 點ID: ${pointId}`, userContext);
    
    // 根據大綱點標題和ID生成固定的3個關鍵詞
    const baseKeywords: { [key: number]: string[] } = {
      1: [
        '"artificial intelligence" "AI development" "technology"',
        '"AI" "technology evolution" "development"',
        '"machine intelligence" "AI progress" "technology"'
      ],
      2: [
        '"machine learning" "algorithms" "optimization"',
        '"deep learning" "neural networks" "AI"',
        '"AI algorithms" "machine learning" "optimization"'
      ],
      3: [
        '"AI applications" "real-world" "implementation"',
        '"intelligent systems" "AI solutions" "deployment"',
        '"AI applications" "real-world" "technology"'
      ],
      4: [
        '"AI challenges" "limitations" "ethics"',
        '"AI ethics" "ethical concerns" "challenges"',
        '"AI risks" "limitations" "mitigation"'
      ],
      5: [
        '"AI impact" "society" "benefits"',
        '"social implications" "artificial intelligence" "impact"',
        '"AI benefits" "human welfare" "society"'
      ]
    };
    
    // 獲取基礎關鍵詞
    const keywords = baseKeywords[pointId] || ['"artificial intelligence" "AI development" "technology"'];
    
    // 隨機選擇一個3個關鍵詞的組合
    const shuffled = keywords.sort(() => 0.5 - Math.random());
    const finalKeywords = shuffled[0];
    
    console.log(`最終生成的3個關鍵詞: "${finalKeywords}"`);
    
    return finalKeywords;
  };

  // 基于文献元数据生成准确分析
  const generateAccurateAnalysisFromInfo = async (title: string, summary: string, authors: string, source: string, pointId: number): Promise<{
    chineseExplanation: string;
  }> => {
    try {
      const prompt = `基于以下文献信息，请生成准确的分析：

文献标题: ${title}
摘要: ${summary}
作者: ${authors}
来源: ${source}

请严格按照以下格式输出：

## 中文概述
[基于文献实际内容的2-3句话概述，准确反映文献的研究重点、方法和发现]

## 英文句子1
英文: "[基于文献实际内容的英文句子，可以直接用于学术写作]"
中文: "[对应的中文翻译]"

## 英文句子2  
英文: "[基于文献实际内容的第二个英文句子]"
中文: "[对应的中文翻译]"

重要要求：
- 必须基于文献的实际内容，不能使用通用模板
- 中文概述要准确反映文献的具体研究内容和发现
- 英文句子要基于文献的具体发现，可以直接引用
- 如果文献是中文，请保持中文内容的准确性
- 如果文献是英文，请保持英文内容的准确性
- 不要使用任何通用的AI技术描述
- 必须反映文献的具体主题和研究内容

请仔细分析文献信息并生成准确的分析：`;

      const response = await callLLM(
        [{ role: 'user', content: prompt }],
        { 
          model: 'openai/gpt-4', 
          temperature: 0.1, 
          timeoutMs: 30000 
        }
      );

      console.log('AI分析响应:', response);

      // 解析AI响应
      let chineseExplanation = '';
      const englishSentences: Array<{english: string, chinese: string}> = [];
      
      // 提取中文概述
      const chineseMatch = response.match(/## 中文概述\s*\n([^#]+)/);
      if (chineseMatch) {
        chineseExplanation = chineseMatch[1].trim();
      }
      
      // 提取英文句子
      const englishMatches = response.match(/## 英文句子\d+\s*\n英文:\s*"([^"]+)"\s*\n中文:\s*"([^"]+)"/g);
      if (englishMatches) {
        for (const match of englishMatches) {
          const sentenceMatch = match.match(/英文:\s*"([^"]+)"\s*\n中文:\s*"([^"]+)"/);
          if (sentenceMatch) {
            englishSentences.push({
              english: sentenceMatch[1],
              chinese: sentenceMatch[2]
            });
          }
        }
      }
      
      // 如果解析失败，使用备用方案
      if (!chineseExplanation || englishSentences.length === 0) {
        console.log('解析失败，使用备用方案');
        
        // 基于摘要内容生成备用分析
        const backupPrompt = `请基于以下文献信息生成简洁的分析：

标题: ${title}
摘要: ${summary.substring(0, 500)}...

请生成：
1. 一句话中文概述
2. 一个英文关键句子及中文翻译`;

        const backupResponse = await callLLM(
          [{ role: 'user', content: backupPrompt }],
          { 
            model: 'openai/gpt-4', 
            temperature: 0.2, 
            timeoutMs: 20000 
          }
        );
        
        chineseExplanation = backupResponse.split('\n')[0] || `该研究基于文献实际内容进行了深入分析，为相关领域提供了重要见解。`;
        englishSentences.push({
          english: `This research provides valuable insights based on comprehensive analysis of the literature content.`,
          chinese: `该研究基于文献内容的综合分析提供了宝贵见解。`
        });
      }
      
      return {
        chineseExplanation
      };
      
    } catch (error) {
      console.error('生成准确分析失败:', error);
      return {
        chineseExplanation: `该研究基于文献实际内容进行了深入分析，为相关领域提供了重要见解。`
      };
    }
  };

  // 深度分析文献（访问全文）
  const performDeepAnalysis = async (ref: Reference, pointId: number) => {
    if (!ref.url) {
      alert('该文献没有可访问的链接');
      return;
    }

    const refId = ref.id;
    setAnalyzingReferences(prev => new Set(prev).add(refId));

    try {
      console.log(`开始深度分析文献: ${ref.title}`);
      console.log(`访问链接: ${ref.url}`);
      
      // 提取全文内容
      const fullTextResult = await extractFullText(ref.url);
      
      if (fullTextResult.success && fullTextResult.content) {
        console.log(`成功提取全文，长度: ${fullTextResult.content.length}`);
        console.log(`全文内容预览: ${fullTextResult.content.substring(0, 500)}...`);
        
        // 基于全文生成准确分析
        const analysis = await generateAccurateAnalysis(ref.title, fullTextResult.content, pointId);
        
        console.log('生成的分析结果:', analysis);
        
        // 更新文献的分析结果
        setSearchResults(prev => prev.map(r => 
          r.id === refId 
            ? { 
                ...r, 
                deepAnalysis: {
                  chineseExplanation: analysis.chineseExplanation,
                  englishSentences: analysis.englishSentences,
                  source: fullTextResult.source,
                  analyzedAt: new Date().toISOString()
                }
              }
            : r
        ));
        
        console.log('深度分析完成');
        alert('深度分析完成！现在显示基于论文全文的准确分析。');
      } else {
        console.log('全文提取失败:', fullTextResult.error);
        alert(`无法访问论文全文: ${fullTextResult.error}\n\n请检查链接是否可访问，或稍后重试。`);
      }
    } catch (error) {
      console.error('深度分析失败:', error);
      alert(`深度分析失败: ${error}\n\n请稍后重试或检查网络连接。`);
    } finally {
      setAnalyzingReferences(prev => {
        const newSet = new Set(prev);
        newSet.delete(refId);
        return newSet;
      });
    }
  };

  // 生成APA7引用格式
  const generateAPA7Citation = (ref: Reference): string => {
    const authors = ref.authors || 'Unknown Author';
    const year = ref.year || new Date().getFullYear();
    const title = ref.title || 'Unknown Title';
    const source = ref.source || 'Unknown Source';
    const url = ref.url || '';
    
    // 清理作者名称，处理多个作者
    const authorList = authors.split(',').map(author => {
      const trimmed = author.trim();
      const parts = trimmed.split(' ');
      if (parts.length >= 2) {
        const lastName = parts[parts.length - 1];
        const firstNames = parts.slice(0, -1).map(name => name.charAt(0) + '.').join(' ');
        return `${lastName}, ${firstNames}`;
      }
      return trimmed;
    });
    
    const formattedAuthors = authorList.join(', ');
    
    if (url) {
      return `${formattedAuthors} (${year}). ${title}. ${source}. ${url}`;
    } else {
      return `${formattedAuthors} (${year}). ${title}. ${source}.`;
    }
  };

  // 生成獨特的摘要
  const generateUniqueSummary = (ref: any, keyword: string, pointId: number, userContext: any, settings: any): string => {
    // 從關鍵字中提取主要概念，避免重複
    const mainConcept = keyword.split(' ')[0]; // 取第一個詞作為主要概念
    
    // 使用用戶上下文生成唯一的摘要變體
    const contextHash = userContext.sessionId + userContext.timestamp + ref.title;
    const variantIndex = Math.abs(contextHash.split('').reduce((a: number, b: string) => a + b.charCodeAt(0), 0)) % 3;
    
    // 為不同的大綱點生成不同的摘要模板
    const summaryTemplates: { [key: number]: string[] } = {
      1: [
        `這篇來自${ref.source}的研究深入探討了${mainConcept}的發展歷程和技術演進，為理解人工智能技術的發展脈絡提供了重要參考。`,
        `該文獻從歷史角度分析了${mainConcept}的起源和發展軌跡，揭示了技術進步的內在邏輯和驅動因素。`,
        `本研究系統性地回顧了${mainConcept}的發展歷程，為相關領域的研究者提供了寶貴的歷史視角。`
      ],
      2: [
        `該文獻詳細闡述了${mainConcept}的技術原理和實現方法，為技術人員提供了實用的技術指導和創新思路。`,
        `本研究深入探討了${mainConcept}的算法設計和優化策略，在技術創新方面具有重要的學術價值。`,
        `該論文從技術角度分析了${mainConcept}的實現難點和解決方案，為技術發展提供了重要啟示。`
      ],
      3: [
        `該文獻通過多個實際案例展示了${mainConcept}的應用效果，證明了其在不同領域的實用價值和發展潛力。`,
        `本研究深入分析了${mainConcept}在各行業的應用模式和成功經驗，為實際應用提供了重要參考。`,
        `該論文探討了${mainConcept}在實際場景中的表現和優化策略，具有重要的實踐指導意義。`
      ],
      4: [
        `該文獻客觀分析了${mainConcept}面臨的技術挑戰和發展瓶頸，為技術改進和未來發展提供了方向指引。`,
        `本研究深入探討了${mainConcept}的局限性問題，為技術發展的未來規劃提供了重要參考和思考。`,
        `該論文系統性地分析了${mainConcept}的挑戰與機遇，為相關領域的發展戰略提供了重要啟示。`
      ],
      5: [
        `該文獻全面評估了${mainConcept}對社會發展的影響和價值，為政策制定和社會規劃提供了重要依據。`,
        `本研究深入探討了${mainConcept}的社會意義和價值體現，為技術發展的社會責任提供了深度思考。`,
        `該論文分析了${mainConcept}對社會變革的推動作用，為理解技術與社會的關係提供了新的視角。`
      ]
    };
    
    const templates = summaryTemplates[pointId] || [
      `該文獻通過實證研究，分析了${mainConcept}在實際應用中的表現和潛在價值，具有重要的理論和實踐意義。`
    ];
    
    // 根據用戶設置生成相應語言的摘要
    if (settings && settings.language === 'en') {
      // 生成英文摘要
      const englishTemplates: { [key: number]: string[] } = {
        1: [
          `This study from ${ref.source} provides an in-depth analysis of ${mainConcept} development and technological evolution, offering valuable insights for understanding the trajectory of artificial intelligence technology.`,
          `This research examines the historical development and current state of ${mainConcept}, providing important theoretical and practical insights for the field.`,
          `The study presents a comprehensive analysis of ${mainConcept} applications, demonstrating significant potential for technological advancement and practical implementation.`
        ],
        2: [
          `This paper explores the core principles and technical foundations of ${mainConcept}, offering detailed insights into machine learning algorithms and deep learning architectures.`,
          `The research investigates the fundamental mechanisms underlying ${mainConcept}, providing valuable understanding of neural network structures and computational methods.`,
          `This study analyzes the theoretical framework of ${mainConcept}, contributing to our understanding of AI technology principles and implementation strategies.`
        ],
        3: [
          `This research demonstrates practical applications of ${mainConcept} across various industries, from finance to healthcare and education, showing significant impact on business operations.`,
          `The study presents real-world case studies of ${mainConcept} implementation, highlighting successful applications and practical benefits in different sectors.`,
          `This paper examines the commercial applications of ${mainConcept}, providing insights into its transformative potential across multiple industries.`
        ]
      };
      
      const englishTemplatesForPoint = englishTemplates[pointId] || englishTemplates[1];
      const index = variantIndex % englishTemplatesForPoint.length;
      return englishTemplatesForPoint[index];
    }
    
    // 根據用戶上下文和文獻標題生成不同的摘要
    const index = variantIndex % templates.length;
    return templates[index];
  };

  // 生成獨特的關鍵句子 - 更加多樣化和實用
  const generateAIKeySentences = (ref: any, keyword: string, pointId: number, userContext: any, settings: any): string[] => {
    // 從關鍵字中提取主要概念
    const mainConcept = keyword.split(' ')[0];
    
    // 根據文獻標題和內容特點，AI分析並提取實用句子
    const title = ref.title || '';
    const source = ref.source || '';
    
    // 使用用戶上下文和標題生成唯一的哈希值
    const contextHash = userContext.sessionId + userContext.timestamp + title + source;
    const titleHash = Math.abs(contextHash.split('').reduce((a: number, b: string) => a + b.charCodeAt(0), 0));
    
    // 根據大綱點ID生成不同的關鍵句子模板
    const pointTemplates: { [key: number]: string[] } = {
      1: [
        `該研究在${mainConcept}發展歷程中的實驗結果顯示，新方法相比傳統方法在準確性上提升了${20 + (titleHash % 15)}%。`,
        `通過深入的理論分析，該研究為${mainConcept}技術的發展提供了重要的歷史背景和演進規律。`,
        `該文獻的發展軌跡分析為${mainConcept}領域的後續研究樹立了重要的里程碑和參考標準。`
      ],
      2: [
        `該研究在${mainConcept}技術原理的實驗中取得了突破性進展，技術指標提升了${25 + (titleHash % 20)}%。`,
        `通過深入的算法分析，該研究為${mainConcept}技術的實現提供了重要的理論基礎和技術指導。`,
        `該文獻的技術創新為${mainConcept}領域的技術發展提供了新的解決方案和實現路徑。`
      ],
      3: [
        `該研究在${mainConcept}應用場景的實際測試中表現優異，應用效果提升了${18 + (titleHash % 12)}%。`,
        `通過多個應用案例的驗證，該研究為${mainConcept}技術的實際應用提供了重要的實踐指導。`,
        `該文獻的應用分析為${mainConcept}領域的產業化發展提供了重要的參考和借鑒。`
      ],
      4: [
        `該研究深入分析了${mainConcept}面臨的技術挑戰，提出了${3 + (titleHash % 5)}個關鍵問題的解決方案。`,
        `通過系統性的挑戰分析，該研究為${mainConcept}技術的未來發展提供了重要的問題識別和解決思路。`,
        `該文獻的挑戰研究為${mainConcept}領域的技術攻關提供了重要的方向指引和策略建議。`
      ],
      5: [
        `該研究全面評估了${mainConcept}對社會發展的影響，在${5 + (titleHash % 8)}個關鍵領域展現了重要價值。`,
        `通過深入的社會影響分析，該研究為${mainConcept}技術的社會責任提供了重要的評估框架。`,
        `該文獻的價值分析為${mainConcept}領域的社會應用提供了重要的價值認知和發展意義。`
      ]
    };
    
    // 優先使用基於大綱點的模板
    const templates = pointTemplates[pointId] || pointTemplates[1];
    const selectedTemplate = templates[titleHash % templates.length];
    
    // 根據文獻標題的具體內容生成更個性化的句子
    const titleLower = title.toLowerCase();
    
    if (titleLower.includes('application') || titleLower.includes('應用')) {
      // 應用類文獻 - 提取實際應用價值
      const performanceGain = 30 + (titleHash % 25);
      const testScenarios = 3 + (titleHash % 4);
      
      return [
        `該研究在${mainConcept}領域的實際應用中取得了顯著成果，實驗數據顯示性能提升達到${performanceGain}%。`,
        `通過${testScenarios}個真實場景的測試驗證，該方法在${mainConcept}相關任務中展現了優越的穩定性和可靠性。`,
        `該技術的產業化部署案例證明了其在${mainConcept}領域的商業價值和實用性。`
      ];
    } else if (titleLower.includes('development') || titleLower.includes('發展') || titleLower.includes('趨勢')) {
      // 發展趨勢類文獻 - 提取發展方向
      const futureYears = 3 + (titleHash % 4);
      const keyDirections = 2 + (titleHash % 3);
      
      return [
        `該研究預測${mainConcept}技術在未來${futureYears}年內將實現重大突破，特別是在算法優化方面。`,
        `通過對現有技術的深入分析，該文獻指出了${mainConcept}領域的${keyDirections}個關鍵發展方向。`,
        `該研究為${mainConcept}技術的標準化制定提供了重要的理論基礎和實踐指導。`
      ];
    } else if (titleLower.includes('challenge') || titleLower.includes('挑戰') || titleLower.includes('問題')) {
      // 挑戰問題類文獻 - 提取解決方案
      const challengeCount = 2 + (titleHash % 3);
      
      return [
        `該研究識別了${mainConcept}領域面臨的${challengeCount}大核心挑戰，並提出了創新的解決方案。`,
        `通過系統性分析，該文獻揭示了${mainConcept}技術發展中的關鍵瓶頸和突破點。`,
        `該研究為解決${mainConcept}領域的實際問題提供了可操作的技術路徑。`
      ];
    } else if (titleLower.includes('review') || titleLower.includes('綜述') || titleLower.includes('survey')) {
      // 綜述類文獻 - 提取總結觀點
      const reviewYears = 8 + (titleHash % 7);
      const paperCount = 120 + (titleHash % 80);
      
      return [
        `該綜述系統性地總結了${mainConcept}領域過去${reviewYears}年的重要進展和關鍵突破。`,
        `通過對${paperCount}多篇相關文獻的分析，該研究揭示了${mainConcept}技術發展的整體脈絡。`,
        `該綜述為${mainConcept}領域的研究者提供了全面的技術現狀和未來發展圖景。`
      ];
    } else if (titleLower.includes('method') || titleLower.includes('方法') || titleLower.includes('算法')) {
      // 方法算法類文獻 - 提取技術細節
      const accuracyGain = 22 + (titleHash % 18);
      const efficiencyGain = 30 + (titleHash % 25);
      
      return [
        `該研究提出的新方法在${mainConcept}相關任務中實現了準確率提升${accuracyGain}%，計算效率提升${efficiencyGain}%。`,
        `通過創新的算法設計，該方法有效解決了${mainConcept}領域長期存在的技術難題。`,
        `該技術的開源實現和詳細實驗報告為${mainConcept}領域的研究提供了寶貴資源。`
      ];
    } else if (titleLower.includes('legal') || titleLower.includes('法律') || titleLower.includes('監管')) {
      // 法律監管類文獻 - 提取法律觀點
      return [
        `該研究從法律角度深入分析了${mainConcept}技術發展中的監管挑戰和合規要求。`,
        `通過對國際法律框架的比較研究，該文獻提出了適合本地化的監管建議。`,
        `該研究為${mainConcept}技術的法律風險評估和合規管理提供了實用指南。`
      ];
    } else if (titleLower.includes('industry') || titleLower.includes('產業') || titleLower.includes('商業')) {
      // 產業商業類文獻 - 提取商業價值
      const marketSize = 100 + (titleHash % 200);
      return [
        `該研究分析了${mainConcept}技術在產業應用中的市場潛力，預計市場規模將達到${marketSize}億美元。`,
        `通過對多個行業案例的研究，該文獻揭示了${mainConcept}技術的商業化路徑。`,
        `該研究為企業在${mainConcept}領域的投資決策和戰略規劃提供了重要參考。`
      ];
    } else {
      // 通用類文獻 - 根據標題特點生成實用句子
      const titleWords = title.split(' ').filter((word: string) => word.length > 3);
      const relevantWord = titleWords.length > 0 ? titleWords[0] : mainConcept;
      const improvement = 18 + (titleHash % 22);
      
      return [
        `該研究在${relevantWord}領域的實驗結果顯示，新方法相比傳統方法在準確性上提升了${improvement}%。`,
        `通過深入的理論分析，該研究為${relevantWord}技術的實際應用提供了重要的指導原則。`,
        `該文獻的實驗設計和數據分析為${relevantWord}領域的後續研究樹立了高標準。`
      ];
    }
    
    // 根據用戶設置生成相應語言的關鍵句子
    if (settings && settings.language === 'en') {
      // 生成英文關鍵句子
      const englishKeySentences: { [key: number]: string[] } = {
        1: [
          `The experimental results in ${mainConcept} development show that the new method improved accuracy by ${20 + (titleHash % 15)}% compared to traditional approaches.`,
          `Through in-depth theoretical analysis, this research provides important guiding principles for the practical application of ${mainConcept} technology.`,
          `The experimental design and data analysis in this study set high standards for subsequent research in the ${mainConcept} field.`
        ],
        2: [
          `This study demonstrates significant advances in ${mainConcept} algorithms, with performance improvements of ${25 + (titleHash % 20)}% in computational efficiency.`,
          `The research provides comprehensive insights into ${mainConcept} architectures, contributing to our understanding of neural network optimization.`,
          `Experimental validation shows that the ${mainConcept} approach achieves superior stability and reliability in real-world applications.`
        ],
        3: [
          `The study presents successful ${mainConcept} implementations across multiple industries, demonstrating substantial commercial value and practical benefits.`,
          `Real-world case studies show that ${mainConcept} technology can achieve ${30 + (titleHash % 25)}% improvement in operational efficiency.`,
          `The research highlights the transformative potential of ${mainConcept} applications in modern business environments.`
        ]
      };
      
      const englishTemplates = englishKeySentences[pointId] || englishKeySentences[1];
      const selectedEnglishTemplate = englishTemplates[titleHash % englishTemplates.length];
      return [selectedEnglishTemplate];
    }
    
    // 如果沒有匹配到特定類型，返回基於大綱點的模板
    return [selectedTemplate];
  };

  // 新增：添加參考文獻到大綱點
  const addReferenceToPoint = async (pointId: number, reference: Reference) => {
    // 自动检查文献库中是否有对应的PDF文件
    try {
      const response = await fetch('/api/reference-library');
      if (response.ok) {
        const library = await response.json();
        const libraryEntry = library.find((entry: any) => 
          entry.title.toLowerCase().includes(reference.title.toLowerCase()) ||
          reference.title.toLowerCase().includes(entry.title.toLowerCase())
        );
        
        if (libraryEntry) {
          console.log(`📄 自动找到PDF文件: ${reference.title} - ${libraryEntry.fileName}`);
          // 自动添加PDF信息到参考文献
          reference = {
            ...reference,
            url: libraryEntry.fileUrl || reference.url
          };
        } else {
          console.log(`📄 文献库中未找到PDF文件: ${reference.title}`);
        }
      }
    } catch (error) {
      console.log('获取文献库信息失败:', error);
    }
    
    setOutlinePoints(prev => prev.map(point => 
      point.id === pointId 
        ? { ...point, references: [...point.references, reference] } : point
    ));
    setSelectedReferences(prev => [...prev, reference]);
  };

  // 新增：手動輸入參考文獻
  const [manualReference, setManualReference] = useState<Omit<Reference, 'id'>>({
    title: '',
    authors: '',
    source: '',
    year: 0,
    summary: '',
    keySentences: [''],
    citation: ''
  });

  // 数据持久化功能
  const saveToLocalStorage = () => {
    try {
      const dataToSave = {
        outlinePoints,
        searchKeywords,
        selectedReferences,
        form,
        activeTab,
        mode,
        isSearching,
        selectedBulletPoint,
        manualInputExpanded,
        searchResults
      };
      localStorage.setItem('assignment-terminator-data', JSON.stringify(dataToSave));
      console.log('✅ 数据已保存到localStorage');
    } catch (error) {
      console.error('❌ 保存数据到localStorage失败:', error);
    }
  };

  const loadFromLocalStorage = () => {
    try {
      const savedData = localStorage.getItem('assignment-terminator-data');
      if (savedData) {
        const parsedData = JSON.parse(savedData);
        if (parsedData.outlinePoints) setOutlinePoints(parsedData.outlinePoints);
        if (parsedData.searchKeywords) setSearchKeywords(parsedData.searchKeywords);
        if (parsedData.selectedReferences) setSelectedReferences(parsedData.selectedReferences);
        if (parsedData.form) setForm(parsedData.form);
        if (parsedData.activeTab) setActiveTab(parsedData.activeTab);
        if (parsedData.mode) setMode(parsedData.mode);
        if (parsedData.selectedBulletPoint) setSelectedBulletPoint(parsedData.selectedBulletPoint);
        if (parsedData.manualInputExpanded) setManualInputExpanded(parsedData.manualInputExpanded);
        if (parsedData.searchResults) setSearchResults(parsedData.searchResults);
        console.log('✅ 数据已从localStorage加载');
      }
    } catch (error) {
      console.error('❌ 从localStorage加载数据失败:', error);
    }
  };

  const addManualReference = async (pointId: number) => {
    if (!manualReference.title.trim()) {
      alert('請填寫參考文獻標題');
      return;
    }
    
    const newReference: Reference = {
      id: `manual-${Date.now()}`,
      title: manualReference.title,
      authors: manualReference.authors,
      source: manualReference.source,
      year: manualReference.year || new Date().getFullYear(),
      summary: manualReference.summary,
      keySentences: manualReference.keySentences.filter(s => s.trim()),
      citation: manualReference.citation
    };
    
    await addReferenceToPoint(pointId, newReference);
    
    // 清空手動輸入
    setManualReference({
      title: '',
      authors: '',
      source: '',
      year: 0,
      summary: '',
      keySentences: [''],
      citation: ''
    });
  };

  // 新增：手動添加文獻的展開/收縮狀態
  const [manualInputExpanded, setManualInputExpanded] = useState<{ [key: number]: boolean }>({});

  // 数据持久化：加载数据
  useEffect(() => {
    loadFromLocalStorage();
  }, []);

  // 数据持久化：保存数据
  useEffect(() => {
    // 延迟保存，避免频繁保存
    const timeoutId = setTimeout(() => {
      saveToLocalStorage();
    }, 1000);

    return () => clearTimeout(timeoutId);
  }, [outlinePoints, searchKeywords, selectedReferences, form, activeTab, mode, selectedBulletPoint, manualInputExpanded, searchResults]);

  // 切換手動輸入的展開/收縮狀態
  const toggleManualInput = (pointId: number) => {
    setManualInputExpanded(prev => ({
      ...prev,
      [pointId]: !prev[pointId]
    }));
  };

  // 新增：檢查編輯模式生成的大綱內容是否詳細
  const checkOutlineDetail = () => {
    const hasDetailedContent = outlinePoints.every(point => 
      point.content && point.content.length > 50 && 
      point.bulletPoints && point.bulletPoints.length >= 3
    );
    
    if (!hasDetailedContent) {
      console.warn('大綱內容不夠詳細，建議重新生成');
    }
    
    return hasDetailedContent;
  };

  // 解析大綱內容的函數
  const parseOutlineContent = (content: string): OutlinePoint[] => {
    if (!content.trim()) return [];
    
    const sections = content.split(/^\d+、/m).filter(section => section.trim());
    const points: OutlinePoint[] = [];
    
    sections.forEach((section, index) => {
      const lines = section.trim().split('\n');
      const title = lines[0]?.replace(/（約.*字）/, '').trim() || `段落 ${index + 1}`;
      
      // 提取字數信息
      const wordMatch = section.match(/（約(\d+)字）/);
      const wordCount = wordMatch ? parseInt(wordMatch[1]) : (index === 0 || index === sections.length - 1 ? 140 : 240);
      
      // 解析內容和子彈點
      const contentLines = lines.slice(1);
      const bulletPoints: string[] = [];
      let regularContent = '';
      
      contentLines.forEach(line => {
        const trimmedLine = line.trim();
        if (trimmedLine.startsWith('-')) {
          bulletPoints.push(trimmedLine.substring(1).trim());
        } else if (trimmedLine && !trimmedLine.startsWith('>') && !trimmedLine.startsWith('a.')) {
          regularContent += trimmedLine + ' ';
        }
      });
      
      points.push({
        id: index + 1,
        title: title,
        content: regularContent.trim(),
        bulletPoints: bulletPoints,
        references: [],
        wordCount: wordCount
      });
    });
    
    return points;
  };

  const handleGenerateOutline = async () => {
    if (!form.title.trim()) {
      alert('請先填寫論文標題');
      return;
    }

    setIsGenerating(true);
    try {
      const response = await fetch('/api/outline', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          title: form.title,
          wordCount: form.totalWords,
          language: form.language,
          tone: form.tone,
          detail: form.detail,
          reference: '', // 暫時設為空字串
          rubric: form.rubric,
          paragraph: form.bodyCount || 3,
          mode: selectedModel
        }),
      });

      if (response.ok) {
        const data = await response.json();
        console.log('API响应数据:', data);
        
        // API返回的是字符串格式的outline
        if (data.outline) {
          setGeneratedContent(data.outline);
          console.log('已更新大綱內容:', data.outline);
          console.log('generatedContent状态已更新');
        } else {
          console.log('API响应中没有outline字段');
        }
        
        setActiveTab('outline');
        setMode('edit');
        console.log('已切换到outline标签页');
      } else {
        const errorData = await response.json();
        alert(`生成失敗: ${errorData.error || '未知錯誤'}`);
      }
    } catch (error) {
      console.error('生成大綱時發生錯誤:', error);
      alert('生成失敗，請檢查網路連接');
    } finally {
      setIsGenerating(false);
    }
  };

  // 清除所有數據的函數
  const clearAllData = () => {
    if (confirm('確定要清除所有數據嗎？此操作無法復原！')) {
      if (confirm('請再次確認：您真的要清除所有數據嗎？')) {
        localStorage.clear();
        setGeneratedContent('');
        setOutlinePoints([]);
        setSearchResults([]);
        setSelectedReferences([]);
        alert('所有數據已清除');
      }
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-700">
      <Head>
        <title>Assignment Terminator</title>
        <meta name="description" content="AI-powered assignment writing assistant" />
      </Head>
      
      <TopNavigation />
      
      <div className="pt-16 px-6">
        <div className="flex">
          {/* 左側：功課設定 */}
          <div className="w-96 border-r border-slate-600 p-4 bg-slate-800 min-h-screen overflow-y-auto">
            <div className="bg-slate-700 rounded-lg shadow-lg p-4">
              <div className="flex items-center justify-between mb-4">
                <h2 className="font-bold text-lg bg-gradient-to-r from-amber-400 to-yellow-300 bg-clip-text text-transparent">功課設定</h2>
                <button
                  onClick={() => setForm(prev => ({ ...prev, settingsExpanded: !prev.settingsExpanded }))}
                  className="text-white bg-slate-600 border-2 border-slate-400 rounded px-3 py-1 hover:bg-slate-500 hover:border-slate-300 transition-colors shadow-lg"
                >
                  {form.settingsExpanded ? '收起' : '展開'}
                </button>
              </div>
              
              {form.settingsExpanded && (
                <div className="space-y-3">
                  <div>
                    <label className="block text-sm font-medium text-slate-300 mb-1">論文標題</label>
                    <input
                      type="text"
                      placeholder="請輸入論文標題"
                      className="w-full border border-slate-500 rounded-lg px-3 py-2 text-sm focus:border-blue-400 focus:ring-blue-400 bg-slate-600 text-white"
                      value={form.title}
                      onChange={(e) => setForm({ ...form, title: e.target.value })}
                    />
                  </div>

                  {/* 段落規劃器 - 重新設計 */}
                  <div className="bg-slate-600 rounded-lg p-3 border border-slate-500">
                    <div className="flex items-center justify-between mb-2">
                      <h3 className="font-bold text-base text-white">🧭 段落規劃器</h3>
                      <button
                        onClick={() => setForm({ ...form, plannerExpanded: !form.plannerExpanded })}
                        className="text-white bg-slate-600 border-2 border-slate-400 rounded px-2 py-1 hover:bg-slate-500 hover:border-slate-300 transition-colors shadow-lg"
                      >
                        {form.plannerExpanded ? '收起' : '展開'}
                      </button>
                    </div>
                    
                    {!form.plannerExpanded ? (
                      // 收起狀態 - 顯示摘要
                      <div className="text-center text-sm text-slate-300">
                        <div className="grid grid-cols-3 gap-2 text-xs">
                          <div>引言: {form.introWords || 140}字</div>
                          <div>主體: {form.bodyCount || 3}段</div>
                          <div>結論: {form.conclusionWords || 140}字</div>
                        </div>
                        <div className="mt-1 flex items-center justify-between">
                          <span>總計: {form.totalWords || 1000}字</span>
                          <input
                            type="number"
                            min="500"
                            max="5000"
                            step="100"
                            value={form.totalWords || 1000}
                            onChange={(e) => setForm(prev => ({ ...prev, totalWords: parseInt(e.target.value) || 1000 }))}
                            className="w-16 px-1 py-1 text-xs bg-slate-600 border border-slate-500 rounded text-white"
                            title="设置总字数"
                          />
                        </div>
                      </div>
                    ) : (
                      // 展開狀態 - 顯示詳細選項
                      <div className="space-y-3">
                        {/* 引言字數 */}
                        <div>
                          <label className="block text-xs font-medium text-slate-300 mb-1">引言字數</label>
                          <input
                            type="number"
                            value={form.introWords || 140}
                            className="w-full border border-slate-500 rounded-lg px-2 py-1 text-center text-xs bg-slate-600 text-white"
                            onChange={(e) => setForm({ ...form, introWords: parseInt(e.target.value) || 140 })}
                          />
                        </div>
                        
                        {/* 主體數量 */}
                        <div>
                          <label className="block text-xs font-medium text-slate-300 mb-1">主體數量</label>
                          <select 
                            className="w-full border border-slate-500 rounded-lg px-2 py-1 text-xs focus:border-blue-400 focus:ring-blue-400 bg-slate-600 text-white"
                            value={form.bodyCount || 3}
                            onChange={(e) => setForm({ ...form, bodyCount: parseInt(e.target.value) || 3 })}
                          >
                            <option value="2">2段</option>
                            <option value="3">3段</option>
                            <option value="4">4段</option>
                            <option value="5">5段</option>
                          </select>
                        </div>
                        
                        {/* 動態生成主體段落設置 */}
                        {Array.from({ length: form.bodyCount || 3 }, (_, index) => (
                          <div key={index} className="border border-slate-500 rounded-lg p-2 bg-slate-600">
                            <div className="text-xs font-medium text-white mb-1">主體{index + 1}</div>
                            <div className="grid grid-cols-2 gap-2 mb-2">
                              <div>
                                <label className="block text-xs text-slate-300 mb-1">字數</label>
                                <input
                                  type="number"
                                  value={form.bodyWords?.[index] || 240}
                                  className="w-full border border-slate-500 rounded-lg px-2 py-1 text-center text-xs bg-slate-600 text-white"
                                  onChange={(e) => {
                                    const newBodyWords = [...(form.bodyWords || [240, 240, 240])];
                                    newBodyWords[index] = parseInt(e.target.value) || 240;
                                    setForm({ ...form, bodyWords: newBodyWords });
                                  }}
                                />
                              </div>
                              <div>
                                <label className="block text-xs text-slate-300 mb-1">大致內容</label>
                                <input
                                  type="text"
                                  placeholder="描述內容..."
                                  value={form.bodyContent?.[index] || ''}
                                  className="w-full border border-slate-500 rounded-lg px-2 py-1 text-xs bg-slate-600 text-white"
                                  onChange={(e) => {
                                    const newBodyContent = [...(form.bodyContent || ['', '', ''])];
                                    newBodyContent[index] = e.target.value;
                                    setForm({ ...form, bodyContent: newBodyContent });
                                  }}
                                />
                              </div>
                            </div>
                          </div>
                        ))}
                        
                        {/* 結論字數 */}
                        <div>
                          <label className="block text-xs font-medium text-slate-300 mb-1">結論字數</label>
                          <input
                            type="number"
                            value={form.conclusionWords || 140}
                            className="w-full border border-slate-500 rounded-lg px-2 py-1 text-center text-xs bg-slate-600 text-white"
                            onChange={(e) => setForm({ ...form, conclusionWords: parseInt(e.target.value) || 140 })}
                          />
                        </div>
                        
                        <div className="text-center text-xs text-slate-300">
                          總計: {form.totalWords || 1000}字
                        </div>
                      </div>
                    )}
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-slate-300 mb-1">內容細節</label>
                    <div className="flex space-x-2">
                      <textarea
                        placeholder="請詳細描述您的作業要求..."
                        className="flex-1 border border-slate-500 rounded-lg px-3 py-2 text-sm focus:border-blue-400 focus:ring-blue-400 min-h-[80px] resize-none bg-slate-600 text-white"
                        value={form.detail}
                        onChange={(e) => setForm({ ...form, detail: e.target.value })}
                      />
                      <button className="px-3 py-2 bg-slate-600 text-white border-2 border-slate-400 rounded-lg hover:bg-slate-500 hover:border-slate-300 transition-colors flex items-center space-x-1 text-sm shadow-lg">
                        <span>📄</span>
                        <span>PDF</span>
                      </button>
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-slate-300 mb-1">評分標準</label>
                    <div className="flex space-x-2">
                      <input
                        type="text"
                        placeholder="請輸入評分標準"
                        className="flex-1 border border-slate-500 rounded-lg px-3 py-2 text-sm focus:border-blue-400 focus:ring-blue-400 bg-slate-600 text-white"
                        value={form.rubric}
                        onChange={(e) => setForm({ ...form, rubric: e.target.value })}
                      />
                      <button className="px-3 py-2 bg-slate-600 text-white border-2 border-slate-400 rounded-lg hover:bg-slate-500 hover:border-slate-300 transition-colors flex items-center space-x-1 text-sm shadow-lg">
                        <span>📄</span>
                        <span>PDF</span>
                      </button>
                    </div>
                  </div>

                  <div className="grid grid-cols-2 gap-3">
                    <div>
                      <label className="block text-sm font-medium text-slate-300 mb-1">語言</label>
                      <select
                        value={form.language}
                        className="w-full border border-slate-500 rounded-lg px-3 py-2 text-sm focus:border-blue-400 focus:ring-blue-400 bg-slate-600 text-white"
                        onChange={(e) => setForm({ ...form, language: e.target.value })}
                      >
                        <option value="中文">中文</option>
                        <option value="英文">英文</option>
                      </select>
                    </div>
                    <div>
                      <label className="block text-sm font-medium text-slate-300 mb-1">語氣</label>
                      <select
                        value={form.tone}
                        className="w-full border border-slate-500 rounded-lg px-3 py-2 text-sm focus:border-blue-400 focus:ring-blue-400 bg-slate-600 text-white"
                        onChange={(e) => setForm({ ...form, tone: e.target.value })}
                      >
                        <option value="正式">正式</option>
                        <option value="半正式">半正式</option>
                        <option value="輕鬆">輕鬆</option>
                      </select>
                    </div>
                  </div>

                  {/* 生成大綱按鈕 */}
                  <button
                    onClick={handleGenerateOutline}
                    disabled={isGenerating}
                    className="w-full bg-gradient-to-r from-yellow-500 to-orange-500 hover:from-yellow-600 hover:to-orange-600 disabled:from-gray-500 disabled:to-gray-600 text-white font-bold py-3 px-4 rounded-lg transition-all duration-200 shadow-lg flex items-center justify-center space-x-2"
                  >
                    {isGenerating ? (
                      <>
                        <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                        <span>生成中...</span>
                      </>
                    ) : (
                      <>
                        <span>📝</span>
                        <span>生成大綱</span>
                      </>
                    )}
                  </button>

                  {/* 清除數據按鈕 */}
                  <button
                    onClick={clearAllData}
                    className="w-full bg-gradient-to-r from-red-500 to-pink-500 hover:from-red-600 hover:to-pink-600 text-white font-bold py-3 px-4 rounded-lg transition-all duration-200 shadow-lg flex items-center justify-center space-x-2"
                  >
                    <span>🗑️</span>
                    <span>清除所有數據</span>
                  </button>
                </div>
              )}
            </div>

            {/* -------- AI 功能 -------- */}
            <div className="bg-slate-700 rounded-lg shadow-lg p-4 mt-4">
              <h3 className="font-bold text-base bg-gradient-to-r from-amber-400 to-yellow-300 bg-clip-text text-transparent mb-4">AI 功能</h3>
              
              <div className="space-y-2">
                <div>
                  <select 
                    value={selectedModel}
                    onChange={(e) => setSelectedModel(e.target.value)}
                    className="w-full border border-slate-500 rounded-lg px-2 py-1 text-sm mb-1 focus:border-blue-400 focus:ring-blue-400 bg-slate-600 text-white"
                  >
                    <option value="gpt-4o">GPT-4o (推荐 - 性价比最高)</option>
                    <option value="claude-3.5">Claude 3.5 Sonnet (顶级质量)</option>
                    <option value="gpt-4">GPT-4 Turbo (高质量长文本)</option>
                    <option value="deepseek-r1">DeepSeek R1 (深度推理)</option>
                    <option value="llama-405b">Llama 3.1 405B (开源高质量)</option>
                    <option value="gemini-flash">Gemini 2.5 Flash (快速经济)</option>
                    <option value="gpt-3.5">GPT-3.5 Turbo (最经济)</option>
                  </select>
                  <button 
                    onClick={handleGenerateOutline}
                    disabled={isGenerating}
                    className={`w-full py-2 px-3 rounded-lg transition-all text-sm shadow-lg border ${
                      isGenerating
                        ? 'bg-slate-400 text-slate-200 cursor-not-allowed'
                        : 'bg-gradient-to-r from-slate-500 to-slate-600 text-white hover:from-slate-400 hover:to-slate-500 border-slate-400'
                    }`}
                  >
                    {isGenerating ? '🔄 生成中...' : '🧠 產生大綱'}
                  </button>
                </div>
                <div>
                  <select 
                    value={selectedModel}
                    onChange={(e) => setSelectedModel(e.target.value)}
                    className="w-full border border-slate-500 rounded-lg px-2 py-1 text-sm mb-1 focus:border-blue-400 focus:ring-blue-400 bg-slate-600 text-white"
                  >
                    <option value="gpt-4o">GPT-4o (推荐 - 性价比最高)</option>
                    <option value="claude-3.5">Claude 3.5 Sonnet (顶级质量)</option>
                    <option value="gpt-4">GPT-4 Turbo (高质量长文本)</option>
                    <option value="deepseek-r1">DeepSeek R1 (深度推理)</option>
                    <option value="llama-405b">Llama 3.1 405B (开源高质量)</option>
                    <option value="gemini-flash">Gemini 2.5 Flash (快速经济)</option>
                    <option value="gpt-3.5">GPT-3.5 Turbo (最经济)</option>
                  </select>
                  <button 
                    onClick={() => handleGenerateDraft('full')}
                    disabled={isGenerating}
                    className="w-full bg-gradient-to-r from-slate-500 to-slate-600 text-white py-2 px-3 rounded-lg hover:from-slate-400 hover:to-slate-500 transition-all text-sm shadow-lg border border-slate-400 disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    {isGenerating ? '✍️ 生成中...' : '✍️ 草稿產生'}
                  </button>
                </div>
                <div>
                  <select className="w-full border border-slate-500 rounded-lg px-2 py-1 text-sm mb-1 focus:border-blue-400 focus:ring-blue-400 bg-slate-600 text-white">
                    <option>ChatGPT 3.5 (0 點)</option>
                    <option>Gemini Flash (3 點)</option>
                  </select>
                  <button className="w-full bg-gradient-to-r from-slate-500 to-slate-600 text-white py-2 px-3 rounded-lg hover:from-slate-400 hover:to-slate-500 transition-all text-sm shadow-lg border border-slate-400">
                    🧑‍🏫 教師評論
                  </button>
                </div>
                <div>
                  <select className="w-full border border-slate-500 rounded-lg px-2 py-1 text-sm mb-1 focus:border-blue-400 focus:ring-blue-400 bg-slate-600 text-white">
                    <option>ChatGPT 3.5 (0 點)</option>
                    <option>Gemini Flash (5 點)</option>
                  </select>
                  <button className="w-full bg-gradient-to-r from-slate-500 to-slate-600 text-white py-2 px-3 rounded-lg hover:from-slate-400 hover:to-slate-500 transition-all text-sm shadow-lg border border-slate-400">
                    📝 GPT-style 修訂
                  </button>
                </div>
                <div>
                  <select className="w-full border border-slate-500 rounded-lg px-2 py-1 text-sm mb-1 focus:border-blue-400 focus:ring-blue-400 bg-slate-600 text-white">
                    <option>ChatGPT 3.5 (0 點)</option>
                    <option>Gemini Flash (5 點)</option>
                  </select>
                  <button className="w-full bg-gradient-to-r from-slate-500 to-slate-600 text-white py-2 px-3 rounded-lg hover:from-slate-400 hover:to-slate-500 transition-all text-sm shadow-lg border border-slate-400">
                    🤖 最終人性化優化
                  </button>
                </div>
              </div>
            </div>
          </div>

          {/* -------- 右：大綱產生器結果 -------- */}
          <div className="flex-1 overflow-y-auto p-6 bg-slate-800 min-h-screen">
            <div className="bg-slate-700 rounded-lg shadow-sm p-6 border border-slate-600">
              <h2 className="text-xl font-bold mb-4 text-white">📝 文字產生區</h2>
              
              <div className="mb-4">
                <div className="flex space-x-2 mb-4">
                  <button 
                    className={`px-4 py-2 rounded-lg border transition-all ${
                      activeTab === 'outline' 
                        ? 'bg-slate-600 text-white border-slate-500' 
                        : 'bg-slate-700 text-slate-300 border-slate-600 hover:bg-slate-600'
                    }`}
                    onClick={() => setActiveTab('outline')}
                  >
                    📑 大綱產生器
                  </button>
                  <button 
                    className={`px-4 py-2 rounded-lg border transition-all ${
                      activeTab === 'draft' 
                        ? 'bg-slate-600 text-white border-slate-500' 
                        : 'bg-slate-700 text-slate-300 border-slate-600 hover:bg-slate-600'
                    }`}
                    onClick={() => setActiveTab('draft')}
                  >
                    ✍️ 初稿
                  </button>
                  <button 
                    className={`px-4 py-2 rounded-lg border transition-all ${
                      activeTab === 'review' 
                        ? 'bg-slate-600 text-white border-slate-500' 
                        : 'bg-slate-700 text-slate-300 border-slate-600 hover:bg-slate-600'
                    }`}
                    onClick={() => setActiveTab('review')}
                  >
                    🧑‍🏫 教師評論
                  </button>
                  <button 
                    className={`px-4 py-2 rounded-lg border transition-all ${
                      activeTab === 'revision' 
                        ? 'bg-slate-600 text-white border-slate-500' 
                        : 'bg-slate-700 text-slate-300 border-slate-600 hover:bg-slate-600'
                    }`}
                    onClick={() => setActiveTab('revision')}
                  >
                    📝 修訂稿
                  </button>
                  <button 
                    className={`px-4 py-2 rounded-lg border transition-all ${
                      activeTab === 'final' 
                        ? 'bg-slate-600 text-white border-slate-500' 
                        : 'bg-slate-700 text-slate-300 border-slate-600 hover:bg-slate-600'
                    }`}
                    onClick={() => setActiveTab('final')}
                  >
                    🤖 最終版本
                  </button>
                </div>
              </div>

              <div className="mb-4">
                <div className="flex items-center space-x-4 mb-2">
                  <label className="block text-sm font-medium text-white">
                    {activeTab === 'outline' && '大綱產生器 :'}
                    {activeTab === 'draft' && '初稿產生 :'}
                    {activeTab === 'review' && '教師評論 :'}
                    {activeTab === 'revision' && '修訂稿 :'}
                    {activeTab === 'final' && '最終版本 :'}
                  </label>
                  <button
                    onClick={() => toggleLock(activeTab)}
                    className={`px-3 py-1 rounded-lg text-sm transition-all ${
                      isCurrentTabLocked 
                        ? 'bg-slate-600 text-white hover:bg-slate-700' 
                        : 'bg-slate-500 text-white hover:bg-slate-600'
                    }`}
                  >
                    {isCurrentTabLocked ? '🔒 已鎖定' : '🔓 未鎖定'}
                  </button>
                </div>
                
                {/* 模式選擇 */}
                {activeTab === 'outline' ? (
                  <div className="flex space-x-4">
                    <label className="flex items-center">
                      <input
                        type="radio"
                        name="mode"
                        value="edit"
                        checked={mode === 'edit'}
                        onChange={(e) => setMode(e.target.value)}
                        disabled={isCurrentTabLocked}
                        className="mr-2"
                      />
                      <span className={`${isCurrentTabLocked ? 'text-slate-500' : 'text-white'}`}>編輯模式</span>
                    </label>
                    <label className="flex items-center">
                      <input
                        type="radio"
                        name="mode"
                        value="search"
                        checked={mode === 'search'}
                        onChange={(e) => setMode(e.target.value)}
                        disabled={isCurrentTabLocked}
                        className="mr-2"
                      />
                      <span className={`${isCurrentTabLocked ? 'text-slate-500' : 'text-white'}`}>文獻搜尋模式</span>
                    </label>
                  </div>
                ) : (
                  <div className="flex space-x-4">
                    <label className="flex items-center">
                      <input
                        type="radio"
                        name="mode"
                        value="edit"
                        checked={true}
                        disabled={true}
                        className="mr-2"
                      />
                      <span className="text-slate-400">編輯模式</span>
                    </label>
                  </div>
                )}
              </div>

            {/* 內容區域 */}
            <div className="bg-slate-700 rounded-lg shadow-lg p-4">
              {/* 大綱產生器 - 根據模式顯示不同內容 */}
              {activeTab === 'outline' && mode === 'edit' && (
                <div className="space-y-6">
                    {outlinePoints.map((point) => (
                      <div key={point.id} className="p-4 bg-slate-700 rounded-lg border border-slate-600">
                        <div className="flex justify-between items-start mb-3">
                          <div className="flex-1">
                            <h4 className="text-lg font-medium text-white">{point.id}. {point.title}</h4>
                            <textarea
                              value={point.content}
                              onChange={(e) => {
                                setOutlinePoints(prev => prev.map(p => 
                                  p.id === point.id ? { ...p, content: e.target.value } : p
                                ));
                              }}
                              className="w-full mt-2 px-3 py-2 bg-slate-600 border border-slate-500 rounded text-white placeholder-slate-400 focus:border-blue-400 focus:ring-blue-400"
                              rows={3}
                              placeholder="在這裡編輯大綱點內容..."
                            />
                            
                            {/* 詳細的bullet points - 編輯模式也應該顯示 */}
                            <div className="mt-3 p-3 bg-slate-600 rounded border border-slate-500">
                              <h5 className="text-sm font-medium text-white mb-2">📝 詳細要點</h5>
                              <div className="space-y-2">
                                {point.bulletPoints.map((bullet, idx) => (
                                  <div key={idx} className="flex items-start">
                                    <span className="text-slate-400 text-xs mr-2 mt-1">•</span>
                                    <textarea
                                      value={bullet}
                                      onChange={(e) => {
                                        const newBulletPoints = [...point.bulletPoints];
                                        newBulletPoints[idx] = e.target.value;
                                        setOutlinePoints(prev => prev.map(p => 
                                          p.id === point.id ? { ...p, bulletPoints: newBulletPoints } : p
                                        ));
                                      }}
                                      className="flex-1 px-2 py-1 bg-slate-700 border border-slate-500 rounded text-white placeholder-slate-400 focus:border-blue-400 focus:ring-blue-400 text-xs"
                                      rows={1}
                                      placeholder="編輯詳細要點..."
                                    />
                                    <button
                                      onClick={() => {
                                        // 删除bullet point
                                        const newBulletPoints = point.bulletPoints.filter((_, i) => i !== idx);
                                        setOutlinePoints(prev => prev.map(p => 
                                          p.id === point.id ? { ...p, bulletPoints: newBulletPoints } : p
                                        ));
                                      }}
                                      className="ml-2 px-2 py-1 bg-red-600 text-white text-xs rounded hover:bg-red-700 transition-colors"
                                      title="删除此要点"
                                    >
                                      ✕
                                    </button>
                                  </div>
                                ))}
                                
                                {/* 添加新详细要点按钮 */}
                                <div className="mt-3 pt-2 border-t border-slate-500">
                                  <button
                                    onClick={() => {
                                      // 添加新的bullet point
                                      const newBulletPoint = '新的详细要点';
                                      setOutlinePoints(prev => prev.map(p => 
                                        p.id === point.id 
                                          ? { ...p, bulletPoints: [...p.bulletPoints, newBulletPoint] }
                                          : p
                                      ));
                                    }}
                                    className="flex items-center px-3 py-2 bg-green-600 text-white text-sm rounded hover:bg-green-700 transition-colors"
                                  >
                                    <span className="mr-2">➕</span>
                                    添加详细要点
                                  </button>
                                </div>
                              </div>
                            </div>
                            
                            <p className="text-slate-400 text-xs mt-2">字數：{point.wordCount}字</p>
                            
                            {/* 显示生成的段落内容 */}
                            {draftSections[point.id] && (
                              <div className="mt-3 p-3 bg-slate-800 rounded border border-slate-500">
                                <h5 className="text-sm font-medium text-green-300 mb-2">✨ 已生成内容</h5>
                                <div className="text-slate-300 text-sm leading-relaxed whitespace-pre-wrap">
                                  {draftSections[point.id]}
                          </div>
                                <div className="mt-2 flex gap-2">
                                  <button
                                    onClick={() => {
                                      const newContent = prompt('编辑生成的内容:', draftSections[point.id]);
                                      if (newContent !== null) {
                                        setDraftSections(prev => ({
                                          ...prev,
                                          [point.id]: newContent
                                        }));
                                      }
                                    }}
                                    className="px-2 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700 transition-colors"
                                  >
                                    ✏️ 编辑
                                  </button>
                                  <button
                                    onClick={() => {
                                      setDraftSections(prev => {
                                        const newSections = { ...prev };
                                        delete newSections[point.id];
                                        return newSections;
                                      });
                                    }}
                                    className="px-2 py-1 bg-red-600 text-white text-xs rounded hover:bg-red-700 transition-colors"
                                  >
                                    🗑️ 删除
                                  </button>
                        </div>
                              </div>
                            )}
                            
                            {/* 生成状态指示器 */}
                            {currentGeneratingSection === point.id && (
                              <div className="mt-3 p-2 bg-blue-900 rounded border border-blue-500">
                                <div className="flex items-center text-blue-300 text-sm">
                                  <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-300 mr-2"></div>
                                  正在生成第{point.id}段内容...
                                </div>
                              </div>
                            )}
                          </div>
                        </div>
                        
                        {/* 參考文獻列表 - 编辑模式 */}
                        {point.references.length > 0 && (
                          <div className="mt-3 p-3 bg-slate-600 rounded border border-slate-500">
                            <h5 className="text-sm font-medium text-white mb-2">📚 參考文獻 ({point.references.length})</h5>
                            <div className="space-y-2">
                              {point.references.map((ref) => (
                                <div key={ref.id} className="p-3 bg-slate-700 rounded border border-slate-500">
                                  <div className="flex items-start justify-between mb-2">
                                    <div className="flex-1">
                                  <p className="text-slate-300 text-sm font-medium">{ref.title}</p>
                                  <p className="text-slate-400 text-xs">{ref.authors} ({ref.year}). {ref.source}</p>
                                    </div>
                                    <div className="flex gap-1 ml-2">
                                      {/* 移动到其他大纲点按钮 */}
                                      <div className="relative group">
                                        <button
                                          className="px-2 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700 transition-colors"
                                          title="移动到其他大纲点"
                                        >
                                          🔄
                                        </button>
                                        {/* 下拉菜单 */}
                                        <div className="hidden group-hover:block absolute right-0 mt-1 bg-slate-800 border border-slate-500 rounded shadow-lg z-10 min-w-[200px]">
                                          <div className="p-2">
                                            <p className="text-xs text-slate-300 mb-2">移动到：</p>
                                            {outlinePoints.filter(p => p.id !== point.id).map(targetPoint => (
                                              <button
                                                key={targetPoint.id}
                                                onClick={() => {
                                                  // 从当前点移除并添加到目标点
                                                  setOutlinePoints(prev => prev.map(p => {
                                                    if (p.id === point.id) {
                                                      return { ...p, references: p.references.filter(r => r.id !== ref.id) };
                                                    } else if (p.id === targetPoint.id) {
                                                      return { ...p, references: [...p.references, ref] };
                                                    }
                                                    return p;
                                                  }));
                                                  alert(`✅ 已将文献移动到大纲点 ${targetPoint.id}: ${targetPoint.title}`);
                                                }}
                                                className="w-full text-left px-2 py-1 text-xs text-slate-300 hover:bg-slate-700 rounded mb-1"
                                              >
                                                {targetPoint.id}. {targetPoint.title.substring(0, 25)}...
                                              </button>
                                    ))}
                                  </div>
                                        </div>
                                      </div>
                                      
                                      {/* 删除按钮 */}
                                      <button
                                        onClick={() => {
                                          if (confirm(`确定要删除这篇文献吗？\n\n${ref.title}`)) {
                                            setOutlinePoints(prev => prev.map(p => 
                                              p.id === point.id 
                                                ? { ...p, references: p.references.filter(r => r.id !== ref.id) }
                                                : p
                                            ));
                                            alert(`✅ 已删除文献: ${ref.title}`);
                                          }
                                        }}
                                        className="px-2 py-1 bg-red-600 text-white text-xs rounded hover:bg-red-700 transition-colors"
                                        title="删除此文献"
                                      >
                                        ✕
                                      </button>
                                    </div>
                                  </div>
                                  
                                  {/* 中文概述 */}
                                  {ref.deepAnalysis?.chineseExplanation && (
                                    <div className="mb-2">
                                      <p className="text-blue-300 text-xs mb-1">📖 中文概述：</p>
                                      <p className="text-slate-300 text-xs leading-relaxed">{ref.deepAnalysis.chineseExplanation}</p>
                                    </div>
                                  )}
                                  
                                  {/* APA7引用格式 */}
                                  <div className="bg-slate-800 p-2 rounded mb-2">
                                    <p className="text-purple-300 text-xs mb-1">📚 APA7引用：</p>
                                    <p className="text-slate-300 text-xs font-mono leading-relaxed">{ref.citation}</p>
                                  </div>
                                  
                                  {/* 操作按钮 */}
                                  <div className="flex gap-2 mt-2 flex-wrap">
                                    {/* 原文链接 */}
                                    {ref.url && (
                                      <a 
                                        href={ref.url} 
                                        target="_blank" 
                                        rel="noopener noreferrer"
                                        className="px-2 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700 transition-colors"
                                        title="访问原文"
                                      >
                                        🔗 訪問原文
                                      </a>
                                    )}
                                    
                                    {/* 自动获取全文按钮 */}
                                    <button
                                      onClick={async () => {
                                        try {
                                          const response = await fetch('/api/download-fulltext', {
                                            method: 'POST',
                                            headers: { 'Content-Type': 'application/json' },
                                            body: JSON.stringify({
                                              referenceId: ref.id,
                                              title: ref.title,
                                              authors: ref.authors,
                                              url: ref.url,
                                              doi: ref.doi
                                            }),
                                          });
                                          
                                          const data = await response.json();
                                          
                                          if (data.success && data.pdfUrl) {
                                            // 打开新窗口下载PDF
                                            window.open(data.pdfUrl, '_blank');
                                            
                                            // 显示成功消息
                                            if (data.saved && data.file) {
                                              alert(`✅ 找到开放获取版本！\n\n来源: ${data.source}\n文件大小: ${(data.file.size / 1024 / 1024).toFixed(2)}MB\n\n✅ 已自动保存到本地文献库\n文件名: ${data.file.name}\n\n您可以在创作初稿时直接调用此文献内容`);
                                              
                                              // 自动更新参考文献的PDF信息
                                              setOutlinePoints(prev => prev.map(point => ({
                                                ...point,
                                                references: point.references.map(r => 
                                                  r.id === ref.id 
                                                    ? { ...r, fileUrl: data.file.url, fileName: data.file.name, fileSize: data.file.size }
                                                    : r
                                                )
                                              })));
                                            } else {
                                              alert(`✅ 找到开放获取版本！\n\n来源: ${data.source}\n\n正在打开下载链接...`);
                                            }
                                          } else {
                                            alert(`❌ ${data.message}\n\n建议：\n${data.suggestions?.join('\n') || '请尝试手动上传PDF'}`);
                                          }
                                        } catch (error) {
                                          console.error('获取全文失败:', error);
                                          alert(`获取全文失败: ${error}`);
                                        }
                                      }}
                                      className="px-2 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700 transition-colors"
                                      title="自动获取全文"
                                    >
                                      📥 自动获取全文
                                    </button>
                                    
                                    {/* 手动上传按钮 */}
                                    <button
                                      onClick={() => {
                                        // 创建文件输入元素
                                        const fileInput = document.createElement('input');
                                        fileInput.type = 'file';
                                        fileInput.accept = '.pdf';
                                        fileInput.onchange = async (e: any) => {
                                          const file = e.target.files[0];
                                          if (!file) return;
                                          
                                          // 检查文件类型
                                          if (!file.type.includes('pdf')) {
                                            alert('❌ 只支持PDF文件格式');
                                            return;
                                          }
                                          
                                          // 检查文件大小 (50MB)
                                          if (file.size > 50 * 1024 * 1024) {
                                            alert('❌ 文件大小超过50MB限制');
                                            return;
                                          }
                                          
                                          // 上传文件
                                          const formData = new FormData();
                                          formData.append('pdf', file);
                                          formData.append('referenceId', ref.id);
                                          formData.append('title', ref.title);
                                          formData.append('authors', ref.authors);
                                          
                                          try {
                                            const response = await fetch('/api/upload-fulltext', {
                                              method: 'POST',
                                              body: formData,
                                            });
                                            
                                            const data = await response.json();
                                            
                                            if (data.success) {
                                              alert(`✅ PDF上传成功！\n\n文件: ${data.file.name}\n大小: ${(data.file.size / 1024 / 1024).toFixed(2)}MB\n\n已保存到本地数据库`);
                                              
                                              // 自动更新参考文献的PDF信息
                                              setOutlinePoints(prev => prev.map(point => ({
                                                ...point,
                                                references: point.references.map(r => 
                                                  r.id === ref.id 
                                                    ? { ...r, fileUrl: data.file.url, fileName: data.file.name, fileSize: data.file.size }
                                                    : r
                                                )
                                              })));
                                            } else {
                                              alert(`❌ 上传失败: ${data.message}`);
                                            }
                                          } catch (error) {
                                            alert(`上传失败: ${error}`);
                                          }
                                        };
                                        fileInput.click();
                                      }}
                                      className="px-2 py-1 bg-teal-600 text-white text-xs rounded hover:bg-teal-700 transition-colors"
                                      title="手动上传PDF"
                                    >
                                      📤 手动上传
                                    </button>
                                    
                                    {/* PDF预览按钮 - 只有在有PDF文件时才显示 */}
                                    {ref.fileUrl && (
                                      <button
                                        onClick={() => {
                                          // 在新窗口打开PDF
                                          window.open(ref.fileUrl, '_blank');
                                        }}
                                        className="px-2 py-1 bg-green-600 text-white text-xs rounded hover:bg-green-700 transition-colors"
                                        title="预览PDF"
                                      >
                                        📄 预览PDF
                                      </button>
                                    )}
                                    
                                    {/* PDF下载按钮 - 只有在有PDF文件时才显示 */}
                                    {ref.fileUrl && (
                                      <button
                                        onClick={() => {
                                          // 下载PDF文件
                                          const link = document.createElement('a');
                                          link.href = ref.fileUrl;
                                          link.download = ref.title.replace(/[^a-zA-Z0-9\s]/g, '') + '.pdf';
                                          link.click();
                                        }}
                                        className="px-2 py-1 bg-purple-600 text-white text-xs rounded hover:bg-purple-700 transition-colors"
                                        title="下载PDF"
                                      >
                                        📥 下载PDF
                                      </button>
                                    )}
                                  </div>
                                </div>
                              ))}
                            </div>
                          </div>
                        )}
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* 文獻搜尋模式 */}
              {activeTab === 'outline' && mode === 'search' && (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <h3 className="text-lg font-semibold text-white">📋 大綱結構 - 點擊搜尋按鈕進行文獻搜尋</h3>
                    <button
                      onClick={() => setForm(prev => ({ ...prev, referenceSettingsExpanded: !prev.referenceSettingsExpanded }))}
                      className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors flex items-center gap-2"
                    >
                      ⚙️ 参考文献设置
                    </button>
                  </div>

                  {/* 顯示分段大綱內容 */}
                  {generatedContent ? (
                    <div className="space-y-4 mb-4">
                      {/* 解析並顯示分段內容 */}
                      {(() => {
                        // 解析大綱內容，分成不同段落
                        const sections = generatedContent.split(/[一二三四五六七八九十]+、/).filter(section => section.trim());
                        const sectionTitles = generatedContent.match(/[一二三四五六七八九十]+、[^-\n]+/g) || [];
                        
                        return sectionTitles.map((title, index) => {
                          const cleanTitle = title.replace(/[一二三四五六七八九十]+、/, '').trim();
                          const sectionContent = sections[index] || '';
                          
                          return (
                            <div key={index} className="p-4 bg-slate-700 rounded-lg border border-slate-600">
                              <div className="flex items-center justify-between mb-3">
                                <h4 className="text-lg font-medium text-white">
                                  {index === 0 ? '一、引言（約 140 字）' : 
                                   index === 1 ? '二、主體段一（約 360 字）' : 
                                   index === 2 ? '三、主體段二（約 360 字）' : 
                                   index === 3 ? '四、結論（約 140 字）' : 
                                   `${index + 1}、${cleanTitle}`}
                                </h4>
                                <div className="flex gap-2">
                                  <button
                                    onClick={() => {
                                      const newContent = prompt('編輯段落內容:', sectionContent);
                                      if (newContent !== null) {
                                        // 更新對應段落的內容
                                        const newSections = [...sections];
                                        newSections[index] = newContent;
                                        const newFullContent = sectionTitles.map((title, i) => 
                                          `${title}\n${newSections[i] || ''}`
                                        ).join('\n\n');
                                        setGeneratedContent(newFullContent);
                                      }
                                    }}
                                    className="px-2 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700 transition-colors"
                                  >
                                    ✏️ 編輯
                                  </button>
                                  <button
                                    onClick={() => {
                                      if (confirm('確定要刪除此段落嗎？')) {
                                        // 移除對應段落
                                        const newSections = sections.filter((_, i) => i !== index);
                                        const newTitles = sectionTitles.filter((_, i) => i !== index);
                                        const newFullContent = newTitles.map((title, i) => 
                                          `${title}\n${newSections[i] || ''}`
                                        ).join('\n\n');
                                        setGeneratedContent(newFullContent);
                                      }
                                    }}
                                    className="px-2 py-1 bg-red-600 text-white text-xs rounded hover:bg-red-700 transition-colors"
                                  >
                                    🗑️ 刪除
                                  </button>
                                </div>
                              </div>
                              {/* 解析並顯示子彈點 */}
                              {(() => {
                                // 解析段落內容，提取子彈點（以 - 開頭的完整段落）
                                const lines = sectionContent.split('\n');
                                const bulletPoints: string[] = [];
                                const regularContent: string[] = [];
                                
                                let currentBullet = '';
                                for (let i = 0; i < lines.length; i++) {
                                  const line = lines[i].trim();
                                  if (line.startsWith('-')) {
                                    // 如果已經有子彈點在累積，先保存
                                    if (currentBullet) {
                                      bulletPoints.push(currentBullet);
                                    }
                                    currentBullet = line;
                                  } else if (line && currentBullet) {
                                    // 如果這行不是以 - 開頭但有內容，且正在累積子彈點，則加入當前子彈點
                                    currentBullet += '\n' + line;
                                  } else if (line && !currentBullet) {
                                    // 如果這行有內容但不在子彈點中，加入常規內容
                                    regularContent.push(line);
                                  }
                                }
                                
                                // 保存最後一個子彈點
                                if (currentBullet) {
                                  bulletPoints.push(currentBullet);
                                }
                                
                                return (
                                  <div className="space-y-3">
                                    {/* 主題句輸入框 */}
                                    <div className="space-y-2">
                                      <label className="text-sm font-medium text-white">📝 主題句：</label>
                                      <textarea
                                        value={regularContent.join('\n')}
                                        onChange={(e) => {
                                          const newSections = [...sections];
                                          newSections[index] = e.target.value + '\n' + bulletPoints.join('\n');
                                          const newFullContent = sectionTitles.map((title, i) => 
                                            `${title}\n${newSections[i] || ''}`
                                          ).join('\n\n');
                                          setGeneratedContent(newFullContent);
                                        }}
                                        placeholder="請輸入主題句..."
                                        className="w-full h-16 p-2 border rounded-lg resize-none bg-slate-800 text-white border-slate-600 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 text-sm"
                                      />
                                    </div>
                                    
                                    {/* 子彈點列表 */}
                                    {bulletPoints.map((bullet, bulletIndex) => (
                                      <div key={bulletIndex} className="flex items-start gap-2">
                                        <textarea
                                          value={bullet}
                                          onChange={(e) => {
                                            const newBulletPoints = [...bulletPoints];
                                            newBulletPoints[bulletIndex] = e.target.value;
                                            const newSections = [...sections];
                                            newSections[index] = regularContent.join('\n') + '\n' + newBulletPoints.join('\n');
                                            const newFullContent = sectionTitles.map((title, i) => 
                                              `${title}\n${newSections[i] || ''}`
                                            ).join('\n\n');
                                            setGeneratedContent(newFullContent);
                                          }}
                                          placeholder="子彈點內容..."
                                          className="flex-1 h-16 p-2 border rounded-lg resize-none bg-slate-800 text-white border-slate-600 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 text-sm"
                                        />
                                        <button
                                          onClick={() => {
                                            const newBulletPoints = bulletPoints.filter((_, i) => i !== bulletIndex);
                                            const newSections = [...sections];
                                            newSections[index] = regularContent.join('\n') + '\n' + newBulletPoints.join('\n');
                                            const newFullContent = sectionTitles.map((title, i) => 
                                              `${title}\n${newSections[i] || ''}`
                                            ).join('\n\n');
                                            setGeneratedContent(newFullContent);
                                          }}
                                          className="px-2 py-1 bg-red-600 text-white text-xs rounded hover:bg-red-700 transition-colors mt-1"
                                        >
                                          🗑️
                                        </button>
                                      </div>
                                    ))}
                                    
                                    {/* 添加子彈點按鈕 */}
                                    <button
                                      onClick={() => {
                                        const newBulletPoints = [...bulletPoints, '- 新的子彈點'];
                                        const newSections = [...sections];
                                        newSections[index] = regularContent.join('\n') + '\n' + newBulletPoints.join('\n');
                                        const newFullContent = sectionTitles.map((title, i) => 
                                          `${title}\n${newSections[i] || ''}`
                                        ).join('\n\n');
                                        setGeneratedContent(newFullContent);
                                      }}
                                      className="px-3 py-1 bg-green-600 text-white text-xs rounded hover:bg-green-700 transition-colors flex items-center gap-1"
                                    >
                                      ➕ 添加子彈點
                                    </button>
                                  </div>
                                );
                              })()}
                            </div>
                          );
                        });
                      })()}
                    </div>
                  ) : null}

                  {/* 参考文献设置面板 */}
                  {form.referenceSettingsExpanded && (
                    <div className="p-4 bg-slate-700 rounded-lg border border-slate-500 mb-4">
                      <h4 className="text-lg font-semibold text-white mb-4">⚙️ 参考文献设置</h4>
                      
                      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        {/* 文献类型选择 */}
                        <div>
                          <label className="block text-sm font-medium text-white mb-2">文献类型</label>
                          <div className="space-y-2">
                            {['journal', 'book', 'conference', 'newspaper', 'website', 'thesis'].map((type) => (
                              <label key={type} className="flex items-center text-white">
                                <input
                                  type="checkbox"
                                  className="mr-2"
                                  checked={form.referenceSettings.documentTypes.includes(type)}
                                  onChange={(e) => {
                                    const newTypes = e.target.checked 
                                      ? [...form.referenceSettings.documentTypes, type]
                                      : form.referenceSettings.documentTypes.filter(t => t !== type);
                                    updateReferenceSettings({ documentTypes: newTypes });
                                  }}
                                />
                                <span className="text-sm">
                                  {type === 'journal' ? '📄 期刊文章' :
                                   type === 'book' ? '📚 书籍' :
                                   type === 'conference' ? '🎤 会议论文' :
                                   type === 'newspaper' ? '📰 报纸文章' :
                                   type === 'website' ? '🌐 网站' :
                                   '🎓 学位论文'}
                                </span>
                              </label>
                            ))}
                          </div>
                        </div>

                        {/* 引用格式选择 */}
                        <div>
                          <label className="block text-sm font-medium text-white mb-2">引用格式</label>
                          <select 
                            className="w-full p-2 bg-slate-600 border border-slate-500 rounded text-white"
                            value={form.referenceSettings.citationFormat}
                            onChange={(e) => updateReferenceSettings({ citationFormat: e.target.value })}
                          >
                            <option value="apa7">APA 7th Edition</option>
                            <option value="apa6">APA 6th Edition</option>
                            <option value="mla9">MLA 9th Edition</option>
                            <option value="chicago">Chicago Style</option>
                            <option value="harvard">Harvard Style</option>
                            <option value="ieee">IEEE Style</option>
                            <option value="vancouver">Vancouver Style</option>
                          </select>
                        </div>

                        {/* 地区和语言 */}
                        <div>
                          <label className="block text-sm font-medium text-white mb-2">地区</label>
                          <select 
                            className="w-full p-2 bg-slate-600 border border-slate-500 rounded text-white mb-3"
                            value={form.referenceSettings.region}
                            onChange={(e) => updateReferenceSettings({ region: e.target.value })}
                          >
                            <option value="global">🌍 全球</option>
                            <option value="north-america">🇺🇸 北美</option>
                            <option value="europe">🇪🇺 欧洲</option>
                            <option value="asia">🌏 亚洲</option>
                            <option value="china">🇨🇳 中国</option>
                            <option value="taiwan">🇹🇼 台湾</option>
                          </select>
                          
                          <label className="block text-sm font-medium text-white mb-2">语言</label>
                          <select 
                            className="w-full p-2 bg-slate-600 border border-slate-500 rounded text-white"
                            value={form.referenceSettings.language}
                            onChange={(e) => updateReferenceSettings({ language: e.target.value })}
                          >
                            <option value="en">English</option>
                          </select>
                        </div>
                      </div>

                      {/* 年份范围 */}
                      <div className="mt-4">
                        <label className="block text-sm font-medium text-white mb-2">年份范围</label>
                        <div className="flex items-center gap-4">
                          <div className="flex items-center gap-2">
                            <label className="text-white text-sm">从</label>
                            <input
                              type="number"
                              min="1900"
                              max={new Date().getFullYear()}
                              value={form.referenceSettings.yearRange.from}
                              onChange={(e) => updateReferenceSettings({ 
                                yearRange: { 
                                  ...form.referenceSettings.yearRange, 
                                  from: parseInt(e.target.value) 
                                } 
                              })}
                              className="w-20 p-2 bg-slate-600 border border-slate-500 rounded text-white text-sm"
                            />
                          </div>
                          <div className="flex items-center gap-2">
                            <label className="text-white text-sm">到</label>
                            <input
                              type="number"
                              min="1900"
                              max={new Date().getFullYear()}
                              value={form.referenceSettings.yearRange.to}
                              onChange={(e) => updateReferenceSettings({ 
                                yearRange: { 
                                  ...form.referenceSettings.yearRange, 
                                  to: parseInt(e.target.value) 
                                } 
                              })}
                              className="w-20 p-2 bg-slate-600 border border-slate-500 rounded text-white text-sm"
                            />
                          </div>
                        </div>
                      </div>

                      {/* 出版商过滤选项 */}
                      <div className="mt-4">
                        <label className="block text-sm font-medium text-white mb-2">出版商过滤</label>
                        <div className="flex items-center">
                          <input
                            type="checkbox"
                            id="excludeLoginRequiredPublishers"
                            className="mr-2"
                            checked={form.referenceSettings.excludeLoginRequiredPublishers}
                            onChange={(e) => updateReferenceSettings({ 
                              excludeLoginRequiredPublishers: e.target.checked 
                            })}
                          />
                          <label htmlFor="excludeLoginRequiredPublishers" className="text-white text-sm">
                            🚫 自动排除需登录的付费出版商
                          </label>
                        </div>
                        <p className="text-xs text-slate-400 mt-1">
                          排除 Taylor & Francis、Springer、Elsevier 等需要付费或登录才能访问的出版商内容
                        </p>
                      </div>

                      {/* 数据库来源 */}
                      <div className="mt-4">
                        <label className="block text-sm font-medium text-white mb-2">数据库来源</label>
                        
                        {/* 无需登录的免费OA源 */}
                        <div className="mb-3">
                          <h4 className="text-sm font-medium text-green-300 mb-2">✅ 无需登录的免费OA源</h4>
                        <div className="grid grid-cols-3 gap-2">
                            {getDatabasesByCategory('free_oa').map((db) => (
                              <label key={db.id} className="flex flex-col text-white p-1.5 bg-slate-600 rounded border border-slate-500 text-xs">
                              <div className="flex items-center mb-1">
                                <input
                                  type="checkbox"
                                  className="mr-1.5 w-3 h-3"
                                    checked={form.referenceSettings.sources.includes(db.id)}
                                  onChange={(e) => {
                                    const newSources = e.target.checked 
                                        ? [...form.referenceSettings.sources, db.id]
                                        : form.referenceSettings.sources.filter(s => s !== db.id);
                                    updateReferenceSettings({ sources: newSources });
                                  }}
                                />
                                <div className="flex-1">
                                  <div className="text-xs font-medium flex items-center leading-tight">
                                    <span className="mr-1">{db.icon}</span>
                                    {db.name}
                                    {db.fullTextAvailable && <span className="ml-1 text-green-400">📥</span>}
                                    {db.apiAvailable && <span className="ml-1 text-blue-400">🔌</span>}
                                  </div>
                                  <div className="text-xs text-slate-400 leading-tight">{db.description}</div>
                                  <div className="text-xs text-green-400 mt-0.5 leading-tight">
                                    专长: {db.specialties.join(', ')}
                                  </div>
                                </div>
                              </div>
                            </label>
                          ))}
                          </div>
                        </div>

                        {/* 需登录的免费OA源 */}
                        <div className="mb-3">
                          <h4 className="text-sm font-medium text-yellow-300 mb-2">⚠️ 需登录的免费OA源</h4>
                          <div className="grid grid-cols-3 gap-2">
                            {getDatabasesByCategory('free_login').map((db) => (
                              <label key={db.id} className="flex flex-col text-white p-1.5 bg-slate-600 rounded border border-slate-500 text-xs">
                              <input
                                type="checkbox"
                                className="mr-2"
                                  checked={form.referenceSettings.sources.includes(db.id)}
                                onChange={(e) => {
                                  const newSources = e.target.checked 
                                      ? [...form.referenceSettings.sources, db.id]
                                      : form.referenceSettings.sources.filter(s => s !== db.id);
                                  updateReferenceSettings({ sources: newSources });
                                }}
                              />
                                <div className="flex-1">
                                  <div className="text-xs font-medium flex items-center leading-tight">
                                    <span className="mr-1">{db.icon}</span>
                                    {db.name}
                                    {db.fullTextAvailable && <span className="ml-1 text-green-400">📥</span>}
                                    {db.apiAvailable && <span className="ml-1 text-blue-400">🔌</span>}
                                  </div>
                                  <div className="text-xs text-slate-400 leading-tight">{db.description}</div>
                                  <div className="text-xs text-yellow-400 mt-1">
                                    专长: {db.specialties.join(', ')} • 需要账号
                                  </div>
                              </div>
                            </label>
                          ))}
                          </div>
                        </div>

                        {/* API专用源 */}
                        <div className="mb-3">
                          <h4 className="text-sm font-medium text-blue-300 mb-2">🔌 API专用源</h4>
                          <div className="grid grid-cols-3 gap-2">
                            {getDatabasesByCategory('api_only').map((db) => (
                              <label key={db.id} className="flex flex-col text-white p-1.5 bg-slate-600 rounded border border-slate-500 text-xs">
                                <div className="flex items-center mb-1">
                                  <input
                                    type="checkbox"
                                    className="mr-1.5 w-3 h-3"
                                    checked={form.referenceSettings.sources.includes(db.id)}
                                    onChange={(e) => {
                                      const newSources = e.target.checked 
                                        ? [...form.referenceSettings.sources, db.id]
                                        : form.referenceSettings.sources.filter(s => s !== db.id);
                                      updateReferenceSettings({ sources: newSources });
                                    }}
                                  />
                                  <div className="flex-1">
                                    <div className="text-xs font-medium flex items-center leading-tight">
                                      <span className="mr-1">{db.icon}</span>
                                      {db.name}
                                      {db.fullTextAvailable && <span className="ml-1 text-green-400">📥</span>}
                                      <span className="ml-1 text-blue-400">🔌</span>
                                    </div>
                                  </div>
                                </div>
                                <div className="text-xs text-slate-400 leading-tight">{db.description}</div>
                                <div className="text-xs text-blue-400 mt-0.5 leading-tight">
                                  专长: {db.specialties.join(', ')} • API访问
                                </div>
                              </label>
                            ))}
                          </div>
                        </div>

                        {/* 数据库统计 */}
                        <div className="mt-3 p-2 bg-slate-700 rounded text-xs text-slate-300">
                          📊 数据库统计: 总计{getDatabaseStats().total}个 | 
                          免费OA: {getDatabaseStats().freeOa}个 | 
                          需登录: {getDatabaseStats().freeLogin}个 | 
                          API专用: {getDatabaseStats().apiOnly}个 | 
                          支持全文: {getDatabaseStats().withFullText}个 | 
                          支持API: {getDatabaseStats().withAPI}个
                        </div>
                      </div>

                      {/* 应用设置按钮 */}
                      <div className="mt-4 pt-4 border-t border-slate-500">
                        <button 
                          onClick={() => {
                            saveReferenceSettings(form.referenceSettings);
                            alert('参考文献设置已保存！');
                            setForm(prev => ({ ...prev, referenceSettingsExpanded: false }));
                          }}
                          className="w-full px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
                        >
                          💾 保存设置
                        </button>
                      </div>
                    </div>
                  )}
                  
                  {/* 大綱點列表 - 每個點都有搜尋按鈕，搜尋界面出現在點擊的點下方 */}
                  {outlinePoints.map((point, index) => (
                    <div key={point.id}>
                      {/* 大綱點 */}
                      <div className="p-4 bg-slate-700 rounded-lg border border-slate-600">
                        <div className="flex justify-between items-start mb-3">
                          <div className="flex-1">
                            <h4 className="text-lg font-medium text-white">{point.id}. {point.title}</h4>
                            <p className="text-slate-300 text-sm mt-1">{point.content}</p>
                            
                            {/* 簡潔的bullet points - 緊湊布局，手動控制搜索 */}
                            <div className="mt-2 space-y-1">
                              {point.bulletPoints.map((bullet, idx) => {
                                const pointBulletKey = `${point.id}-${idx}`;
                                const isKeywordGenerated = !!searchKeywords[pointBulletKey];
                                
                                return (
                                  <div key={idx} className="flex items-start py-1">
                                    <span className="text-slate-400 text-xs mr-2 mt-0.5">•</span>
                                    <div className="flex-1">
                                      <div className="text-slate-300 text-xs">{bullet}</div>
                                      {isKeywordGenerated && (
                                        <div className="mt-1">
                                          <span className="inline-flex items-center px-2 py-1 text-xs rounded bg-blue-600 text-white">
                                            {searchKeywords[pointBulletKey]}
                                          </span>
                                </div>
                                      )}
                                    </div>
                                    <button
                                      onClick={() => {
                                        // 生成关键词（支持重新生成）
                                        const bulletKeyword = generateBulletPointKeywords(bullet, point.id, idx);
                                        setSearchKeywords(prev => ({
                                          ...prev, 
                                          [pointBulletKey]: bulletKeyword
                                        }));
                                        // 设置当前选中的bullet point
                                        setSelectedBulletPoint(pointBulletKey);
                                        // 同时激活主搜索窗口（但不覆盖bullet point关键词）
                                        if (!searchKeywords[point.id]) {
                                          const mainKeyword = generateEnglishKeywords(point.title, point.id);
                                          setSearchKeywords(prev => ({...prev, [point.id]: mainKeyword}));
                                        }
                                      }}
                                      disabled={isSearching}
                                      className="ml-2 px-3 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700 transition-colors disabled:opacity-50 whitespace-nowrap"
                                    >
                                      生成关键词
                                    </button>
                                  </div>
                                );
                              })}
                              

                            </div>
                            
                            <p className="text-slate-400 text-xs mt-2">字數：{point.wordCount}字</p>
                          </div>
                          <button
                            onClick={() => {
                              const isPointSearchActivated = !!searchKeywords[point.id];
                              
                              if (!isPointSearchActivated) {
                                // 第一次点击：只生成关键词，显示搜索窗口
                                const basicKeywords = generateEnglishKeywords(point.title, point.id);
                                setSearchKeywords(prev => ({...prev, [point.id]: basicKeywords}));
                                setSelectedBulletPoint(null); // 清除bullet point选择
                              } else {
                                // 第二次点击：执行搜索
                                const currentKeyword = searchKeywords[point.id] || '';
                                if (currentKeyword) {
                                  handleSearchReferences(currentKeyword, point.id, true);
                                }
                              }
                            }}
                            disabled={isSearching}
                            className="px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700 transition-colors disabled:opacity-50"
                          >
                            {searchKeywords[point.id] ? '🔄 重新搜尋' : '🔍 搜尋文獻'}
                          </button>
                        </div>
                        
                        {/* 參考文獻列表 - 搜索模式 */}
                        {point.references.length > 0 && (
                          <div className="mt-3 p-3 bg-slate-600 rounded border border-slate-500">
                            <h5 className="text-sm font-medium text-white mb-2">📚 參考文獻 ({point.references.length})</h5>
                            <div className="space-y-2">
                              {point.references.map((ref) => (
                                <div key={ref.id} className="p-3 bg-slate-700 rounded border border-slate-500">
                                  <div className="flex items-start justify-between mb-2">
                                    <div className="flex-1">
                                  <p className="text-slate-300 text-sm font-medium">{ref.title}</p>
                                  <p className="text-slate-400 text-xs">{ref.authors} ({ref.year}). {ref.source}</p>
                                    </div>
                                    <div className="flex gap-1 ml-2">
                                      {/* 移动到其他大纲点按钮 */}
                                      <div className="relative group">
                                        <button
                                          className="px-2 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700 transition-colors"
                                          title="移动到其他大纲点"
                                        >
                                          🔄
                                        </button>
                                        {/* 下拉菜单 */}
                                        <div className="hidden group-hover:block absolute right-0 mt-1 bg-slate-800 border border-slate-500 rounded shadow-lg z-10 min-w-[200px]">
                                          <div className="p-2">
                                            <p className="text-xs text-slate-300 mb-2">移动到：</p>
                                            {outlinePoints.filter(p => p.id !== point.id).map(targetPoint => (
                                              <button
                                                key={targetPoint.id}
                                                onClick={() => {
                                                  // 从当前点移除并添加到目标点
                                                  setOutlinePoints(prev => prev.map(p => {
                                                    if (p.id === point.id) {
                                                      return { ...p, references: p.references.filter(r => r.id !== ref.id) };
                                                    } else if (p.id === targetPoint.id) {
                                                      return { ...p, references: [...p.references, ref] };
                                                    }
                                                    return p;
                                                  }));
                                                  alert(`✅ 已将文献移动到大纲点 ${targetPoint.id}: ${targetPoint.title}`);
                                                }}
                                                className="w-full text-left px-2 py-1 text-xs text-slate-300 hover:bg-slate-700 rounded mb-1"
                                              >
                                                {targetPoint.id}. {targetPoint.title.substring(0, 25)}...
                                              </button>
                                    ))}
                                  </div>
                                        </div>
                                      </div>
                                      
                                      {/* 删除按钮 */}
                                      <button
                                        onClick={() => {
                                          if (confirm(`确定要删除这篇文献吗？\n\n${ref.title}`)) {
                                            setOutlinePoints(prev => prev.map(p => 
                                              p.id === point.id 
                                                ? { ...p, references: p.references.filter(r => r.id !== ref.id) }
                                                : p
                                            ));
                                            alert(`✅ 已删除文献: ${ref.title}`);
                                          }
                                        }}
                                        className="px-2 py-1 bg-red-600 text-white text-xs rounded hover:bg-red-700 transition-colors"
                                        title="删除此文献"
                                      >
                                        ✕
                                      </button>
                                    </div>
                                  </div>
                                  
                                  {/* 中文概述 */}
                                  {ref.deepAnalysis?.chineseExplanation && (
                                    <div className="mb-2">
                                      <p className="text-blue-300 text-xs mb-1">📖 中文概述：</p>
                                      <p className="text-slate-300 text-xs leading-relaxed">{ref.deepAnalysis.chineseExplanation}</p>
                                    </div>
                                  )}
                                  
                                  {/* APA7引用格式 */}
                                  <div className="bg-slate-800 p-2 rounded mb-2">
                                    <p className="text-purple-300 text-xs mb-1">📚 APA7引用：</p>
                                    <p className="text-slate-300 text-xs font-mono leading-relaxed">{ref.citation}</p>
                                  </div>
                                  
                                  {/* 操作按钮 */}
                                  <div className="flex gap-2 mt-2 flex-wrap">
                                    {/* 原文链接 */}
                                    {ref.url && (
                                      <a 
                                        href={ref.url} 
                                        target="_blank" 
                                        rel="noopener noreferrer"
                                        className="px-2 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700 transition-colors"
                                        title="访问原文"
                                      >
                                        🔗 訪問原文
                                      </a>
                                    )}
                                    
                                    {/* 自动获取全文按钮 */}
                                    <button
                                      onClick={async () => {
                                        try {
                                          const response = await fetch('/api/download-fulltext', {
                                            method: 'POST',
                                            headers: { 'Content-Type': 'application/json' },
                                            body: JSON.stringify({
                                              referenceId: ref.id,
                                              title: ref.title,
                                              authors: ref.authors,
                                              url: ref.url,
                                              doi: ref.doi
                                            }),
                                          });
                                          
                                          const data = await response.json();
                                          
                                          if (data.success && data.pdfUrl) {
                                            // 打开新窗口下载PDF
                                            window.open(data.pdfUrl, '_blank');
                                            
                                            // 显示成功消息
                                            if (data.saved && data.file) {
                                              alert(`✅ 找到开放获取版本！\n\n来源: ${data.source}\n文件大小: ${(data.file.size / 1024 / 1024).toFixed(2)}MB\n\n✅ 已自动保存到本地文献库\n文件名: ${data.file.name}\n\n您可以在创作初稿时直接调用此文献内容`);
                                              
                                              // 自动更新参考文献的PDF信息
                                              setOutlinePoints(prev => prev.map(point => ({
                                                ...point,
                                                references: point.references.map(r => 
                                                  r.id === ref.id 
                                                    ? { ...r, fileUrl: data.file.url, fileName: data.file.name, fileSize: data.file.size }
                                                    : r
                                                )
                                              })));
                                            } else {
                                              alert(`✅ 找到开放获取版本！\n\n来源: ${data.source}\n\n正在打开下载链接...`);
                                            }
                                          } else {
                                            alert(`❌ ${data.message}\n\n建议：\n${data.suggestions?.join('\n') || '请尝试手动上传PDF'}`);
                                          }
                                        } catch (error) {
                                          console.error('获取全文失败:', error);
                                          alert(`获取全文失败: ${error}`);
                                        }
                                      }}
                                      className="px-2 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700 transition-colors"
                                      title="自动获取全文"
                                    >
                                      📥 自动获取全文
                                    </button>
                                    
                                    {/* 手动上传按钮 */}
                                    <button
                                      onClick={() => {
                                        // 创建文件输入元素
                                        const fileInput = document.createElement('input');
                                        fileInput.type = 'file';
                                        fileInput.accept = '.pdf';
                                        fileInput.onchange = async (e: any) => {
                                          const file = e.target.files[0];
                                          if (!file) return;
                                          
                                          // 检查文件类型
                                          if (!file.type.includes('pdf')) {
                                            alert('❌ 只支持PDF文件格式');
                                            return;
                                          }
                                          
                                          // 检查文件大小 (50MB)
                                          if (file.size > 50 * 1024 * 1024) {
                                            alert('❌ 文件大小超过50MB限制');
                                            return;
                                          }
                                          
                                          // 上传文件
                                          const formData = new FormData();
                                          formData.append('pdf', file);
                                          formData.append('referenceId', ref.id);
                                          formData.append('title', ref.title);
                                          formData.append('authors', ref.authors);
                                          
                                          try {
                                            const response = await fetch('/api/upload-fulltext', {
                                              method: 'POST',
                                              body: formData,
                                            });
                                            
                                            const data = await response.json();
                                            
                                            if (data.success) {
                                              alert(`✅ PDF上传成功！\n\n文件: ${data.file.name}\n大小: ${(data.file.size / 1024 / 1024).toFixed(2)}MB\n\n已保存到本地数据库`);
                                              
                                              // 自动更新参考文献的PDF信息
                                              setOutlinePoints(prev => prev.map(point => ({
                                                ...point,
                                                references: point.references.map(r => 
                                                  r.id === ref.id 
                                                    ? { ...r, fileUrl: data.file.url, fileName: data.file.name, fileSize: data.file.size }
                                                    : r
                                                )
                                              })));
                                            } else {
                                              alert(`❌ 上传失败: ${data.message}`);
                                            }
                                          } catch (error) {
                                            alert(`上传失败: ${error}`);
                                          }
                                        };
                                        fileInput.click();
                                      }}
                                      className="px-2 py-1 bg-teal-600 text-white text-xs rounded hover:bg-teal-700 transition-colors"
                                      title="手动上传PDF"
                                    >
                                      📤 手动上传
                                    </button>
                                    
                                    {/* PDF预览按钮 - 只有在有PDF文件时才显示 */}
                                    {ref.fileUrl && (
                                      <button
                                        onClick={() => {
                                          // 在新窗口打开PDF
                                          window.open(ref.fileUrl, '_blank');
                                        }}
                                        className="px-2 py-1 bg-green-600 text-white text-xs rounded hover:bg-green-700 transition-colors"
                                        title="预览PDF"
                                      >
                                        📄 预览PDF
                                      </button>
                                    )}
                                    
                                    {/* PDF下载按钮 - 只有在有PDF文件时才显示 */}
                                    {ref.fileUrl && (
                                      <button
                                        onClick={() => {
                                          // 下载PDF文件
                                          const link = document.createElement('a');
                                          link.href = ref.fileUrl;
                                          link.download = ref.title.replace(/[^a-zA-Z0-9\s]/g, '') + '.pdf';
                                          link.click();
                                        }}
                                        className="px-2 py-1 bg-purple-600 text-white text-xs rounded hover:bg-purple-700 transition-colors"
                                        title="下载PDF"
                                      >
                                        📥 下载PDF
                                      </button>
                                    )}
                                  </div>
                                </div>
                              ))}
                            </div>
                          </div>
                        )}
                      </div>
                    </div>
                  ))}
                </div>
              )}

              {activeTab === 'draft' && (
                <div>
                  <h3 className="text-lg font-medium text-white mb-4">草稿內容</h3>
                  <div className="space-y-4">
                    <button 
                      onClick={() => handleGenerateDraft('full')}
                      disabled={isGenerating}
                      className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors disabled:opacity-50"
                    >
                      {isGenerating ? '生成中...' : '📝 生成完整草稿'}
                    </button>
                    
                    <div className="text-slate-300">
                      {generatedContent || '請先生成草稿內容'}
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}